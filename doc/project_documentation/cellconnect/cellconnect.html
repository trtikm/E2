<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="icon" href="../../E2_icon.svg" sizes="any" type="image/svg">
<link rel="stylesheet" type="text/css" href="../../text_style.css">
<title>E2: cellconnect </title>
</head>
<body>
<h1>E2: cellconnect</h1>
<p>
This module provides algorithms which are able to <em>set-up</em> synapses between cells in
a neural tissue s.t. the resulting tissue has some desired <em>network properties</em>.
It means that here we consider a neural tissue to be a network (graph) with cells
representing nodes and synapses representing links (edges). A network property is
then any property we can tell about a network from the point of view of the graph/network
theory. Here we primarily focus on the following very important
network properties: small-world property, power-law distribution of in/out-degrees
of cells (i.e. is the network scale-free), and clustering coefficients of cells.
</p>
<h2 id="motivation">Motivation</h2>
<p>
Number of cells in a neural tissue can be quite large. An exact specification of
connections between cells requires a space comparable with the size of the tissue
itself (remember that number of synapses is dominant in any realistic tissue).
And that is not acceptable. Our goal thus is to provide an alternative
specification with the following properties:
</p>
<ul><li>
    It has negligible memory requirements compared to size of the tissue.
</li><li>
    It still allow us to specify desired network properties of the tissue.
</li><li>
    We can construct algorithms which can efficiently interconnect cells
    in the tissue according to the specification.
</li></ul>
<p>
Our solution splits the whole problem into a sequence of three sub-problems.
First, we interconnect only cells appearing in the same column. Then
we spread synapses from original cells to cells in other columns. And we
finish by setting up delimiters of migration lists for each cells in the tissue.
These three parts are described in details in the following three sections.
</p>
<p>
Remember that to interconnect a source and a target cell by a synapse equals
to setting coordinates of the source cell to the synapse in the territory of
the target cells. Therefore, the first two sub-problems only set coordinates
of source cells to synapses. No other properties of synapses are neither read
nor written.
</p>
<h2 id="column_setup">Set-up of synapses in column</h2>
<p>
Each column in a neural tissue has exactly the same structure. We can thus apply
the same set-up procedure for each column independently. Clearly, it suffices
if we describe in this section only the set-up procedure for any given column.
The structure of the column (along the columnar axis) is the following.
</p>
<img src="./column_and_sensory_cells.svg" alt="[column_and_sensory_cells.svg]">
<p>
We see <i>K</i> kinds of tissue cells. <i>i</i>-th kind has exactly
<i>N<sub>i</sub></i> cells. Each cell of <i>i</i>-th kind has a territory for exactly
<i>T<sub>i</sub></i> synapses. We further see in the picture the mapping of sensory cells
to their coordinates along the columnar axis. There are <i>S</i> kinds of sensory cells
and <i>i</i>-th kind has exactly <i>N<sub>i</sub></i> sensory cells.
</p><p>
Each synapse is associated with tissue coordinates of its source cell (projecting the axon).
Our goal is to set-up coordinates to source cells of each synapse in the territory of each cell
in the column. Note that all these coordinates may differ only in the third coordinate (i.e.
along the columnar axis).
</p><p>
Ideally we should specify for each tissue cell and each sensory cell how many synapses it
projects into what tissue cell. Nevertheless, the size of this specification depends
on the length of the columnar axis of the tissue, i.e. it can be large
(<i>C&times;C<sub>S</sub></i> records). We thus propose a different specification,
where we focus on <em>kinds</em> of cell instead of individual cells.
Namely, for each kind of tissue cells
0 &le; <i>i</i> &lt; <i>K</i>
and for each kind of tissue or sensory cells
0 &le; <i>j</i> &lt; <i>K</i>+<i>S</i>
we specify a number of synapses
<i>a<sub>i,j</sub></i>
which are projected from <em>each</em> cell of the kind <i>j</i> to
<em>each</em> cell of the kind <i>i</i>. We can put all the numbers
<i>a<sub>i,j</sub></i>
into a matrix <i>A</i> of dimensions <i>K</i>&times;(<i>K</i>+<i>S</i>):
</p>
<img src="./column_fill_matrix.svg" alt="[column_fill_matrix.svg]">
<p>
For each
0 &le; <i>i</i> &lt; <i>K</i>
the matrix <i>A</i> must satisfy
<i>T<sub>i</sub>N<sub>i</sub></i> =
(<i>a</i><sub><i>i</i>,0</sub><i>N</i><sub>0</sub> + &hellip; +
<i>a</i><sub><i>i,i</i></sub><i>N</i><sub><i>i</i></sub> + &hellip; +
<i>a</i><sub><i>i,K</i>&minus;1</sub><i>N</i><sub><i>K</i>&minus;1</sub>) +
(<i>a</i><sub><i>i,K</i></sub><i>N</i><sub><i>K</i></sub> + &hellip; +
<i>a</i><sub><i>i</i>,<i>K+S</i>&minus;1</sub><i>N</i><sub><i>K+S</i>&minus;1</sub>).
</p><p>
Let <i>i</i> be a kind of tissue cells (i.e. 0 &le; <i>i</i> &lt; <i>K</i>),
<i>j</i> be an index of some tissue cell of the kind <i>i</i> (i.e.
0 &le; <i>j</i> &lt; <i>N<sub>i</sub></i>), and <i>k</i> be an index of a synapse
in the territory of the <i>j</i>-th cell of the kind <i>i</i> (i.e.
0 &le; <i>k</i> &lt; <i>T<sub>i</sub></i>). Then the number
<i>k</i><i>N</i><sub><i>i</i></sub> + <i>j</i>
is a <i>columnar identifier</i> of the synapse at the <i>k</i>-th index in
the territory of the <i>j</i>-th cell of the kind <i>i</i>.
In the following picture we can see a graphical representation of columnar identifiers
of synapses.
</p>
<img src="./columnar_identifiers_of_synapses.svg" alt="[columnar_identifiers_of_synapses.svg]">
<p>
Let us denote a columnar coordinate of a the <i>j</i>-th cell of either tissue or sensory
cell kind <i>i</i> (i.e.
0 &le; <i>j</i> &lt; <i>N<sub>i</sub></i>, 0 &le; <i>i</i> &lt; <i>K</i>+<i>S</i>)
as <i>c</i><sub><i>i</i>:<i>j</i></sub>. Clearly,
<i>c</i><sub><i>i</i>:<i>j</i></sub> =
    <i>T</i><sub>0</sub><i>N</i><sub>0</sub> +
    &hellip; +
    <i>T</i><sub><i>i</i>&minus;1</sub><i>N</i><sub><i>i</i>&minus;1</sub> + <i>j</i>.
</p><p>
Let us consider a synapse with a columnar identifier <i>k</i> in the territory of
a tissue cell of a kind <i>i</i>. If (<i>x</i>,<i>y</i>) are tissue coordinates
of the considered column, then the procedure sets-up coordinates to the source cell of that
synapse as (<i>x</i>,<i>y</i>,<i>c</i><sub><i>j</i>:<i>l</i></sub>), where <i>j</i>
and <i>l</i> mean the following. The cell kind <i>j</i> is a unique index of
a column in the matrix <i>A</i> satisfying
0 &le; <i>k</i> &minus; (<i>a</i><sub><i>i</i>,0</sub><i>N</i><sub>0</sub> + &hellip; +
    <i>a</i><sub><i>i</i>,<i>j</i>&minus;1</sub><i>N</i><sub><i>j</i>&minus;1</sub>)
    &lt; <i>a</i><sub><i>i</i>,<i>j</i></sub><i>N</i><sub><i>j</i></sub>.
The cell index <i>l</i> is then a unique value
&lfloor;(<i>k</i> &minus; (<i>a</i><sub><i>i</i>,0</sub><i>N</i><sub>0</sub> + &hellip; +
    <i>a</i><sub><i>i</i>,<i>j</i>&minus;1</sub><i>N</i><sub><i>j</i>&minus;1</sub>))
    / <i>a</i><sub><i>i</i>,<i>j</i></sub>&rfloor;.
</p><p>
We are ready to describe whole the procedure. It iterates over tissue kinds
<i>i</i>=0,&hellip;,<i>K</i>&minus;1. For each kind <i>i</i> it performs two
iterations simultaneously. First, it iterates over synapse identifiers
<i>k</i>=0,&hellip;,<i>T</i><sub><i>r</i></sub><i>N</i><sub><i>r</i></sub>&minus;1
for each tissue and sensory kind
<i>r</i>=0,&hellip;,<i>K+S</i>&minus;1.
And second, it iterates over the sequence
<i>a</i><sub><i>i</i>,0</sub><i>N</i><sub>0</sub> + &hellip; +
    <i>a</i><sub><i>i</i>,<i>K+S</i>&minus;1</sub><i>N</i><sub><i>K+S</i>&minus;1</sub>
in order to directly obtain the columnar coordinate <i>c</i><sub><i>j</i>:<i>l</i></sub>
for the corresponding synapse identifier <i>k</i>.
</p><p>
The algorithm which sets-up all columns in the tissue (each column
exactly the same way) according to the matrix <i>A</i> is implemented
as a function <tt>fill_coords_of_source_cells_of_synapses_in_tissue</tt>
in files
</p>
<ul><li>
    <a href="../../../code/cellconnect/include/cellconnect/fill_coords_of_source_cells_of_synapses_in_tissue.hpp">
        fill_coords_of_source_cells_of_synapses_in_tissue.hpp</a>,
</li><li>
    <a href="../../../code/cellconnect/src/fill_coords_of_source_cells_of_synapses_in_tissue.cpp">
        fill_coords_of_source_cells_of_synapses_in_tissue.cpp</a>.
</li></ul>
<p>
The algorithm accepts (besides the matrix <i>A</i>) a number of threads available
for the computation. This number determines how many columns will be set-up simultaneously.
The described procedure for the set-up of a single given column is implemented in that
<tt>cpp</tt> file as a function
<tt>fill_coords_of_source_cells_of_synapses_in_single_column</tt>.
</p>
<h2 id="spreading_synapses">Spreading synapses amongst columns</h2>
<p>
It is sufficient to provide an algorithm which spreads synapses only between
tissue cells of a given source kind <i>s</i> and a target kind <i>t</i>. The algorithm
can then be called several times, for each pair of a source and target kinds we need.
</p><p>
First we have to specify <em>where</em> we move synapses from their original places.
We do so in terms of whole columns (i.e. <em>not</em> per cell nor even per synapse).
For each column in the tissue we define its <em>neighbourhood</em>. A neighbourhood
is simply a rectangular region in the tissue spanning over <i>m</i> columns along
<i>X</i> axis and <i>n</i> columns along <i>Y</i> axis.
In order to ensure an existence of the central column in a neighbourhood we always
assume that both <i>m</i> and <i>n</i> are odd numbers greater than 1. Neighbourhoods
of all columns have the same fixed dimensions
<i>m</i>&times;<i>n</i>. Nevertheless, for each column we define its own shift vector
from the column to the central column of its neighbourhood. We specify these shift
vectors using a so called <em>column-shift function</em> <i>F</i>. It accepts tissue coordinates
of a column and it returns tissue coordinates of the central column of the neighbourhood.
We postpone a detailed description of <i>F</i> to a
<a href="./cellconnect.html#column_shift_function">separate section</a>
below. The left part of the following picture provides a graphical representation
of the described notion of columns' neighbourhoods.
</p>
<img src="./spread_synapses_top_view.svg" alt="[spread_synapses_top_view.svg]">
<p>
We see the source column at tissue coordinates (<i>x,y</i>). The column-shift
function <i>F</i> maps the source column into the central column in its
neighbourhood. The neighbourhood forms a rectangle of <i>m</i>&times;<i>n</i>
target columns.
</p><p>
The algorithm is supposed to spread synapses from the source column into target columns.
We know exactly what synapses to move. It is each synapse in the territory
of any cell of the kind <i>t</i> whose coordinates of the source cells identify
a tissue cell of the kind <i>s</i>. Each of these synapses is uniquely identified by
its synapse identifier (see the
<a href="./cellconnect.html#column_setup">previous section</a>).
Let us denote a set of these synapse identifiers as <em>spreading identifiers</em>
<i>D</i><sub><i>s,t</i></sub>. We further know the exact count of the spread synapses
(i.e. the size of the set <i>D</i><sub><i>s,t</i></sub>). We remember from the
<a href="./cellconnect.html#column_setup">previous section</a>
(namely from the matrix <i>A</i>) that tissue cells of the target kind <i>t</i> have
together in their territories exactly <i>a<sub>t,s</sub></i> synapses from each tissue
cell of the source kind <i>s</i>. Since there is exactly <i>N<sub>s</sub></i> tissue
cells of the source kind <i>s</i>, we thus have to spread exactly
<i>a<sub>t,s</sub>N<sub>s</sub></i> synapses. Now appears a question
how we distribute all those <i>a<sub>t,s</sub>N<sub>s</sub></i> synapses (whose
positions in the source column are defined by the spreading identifiers) into
<i>m</i>&times;<i>n</i>
columns in the neighbourhood. We specify this distribution using a matrix <i>H</i>
depicted on the right part of the picture. Observe the direct correspondence between
elements of the matrix and columns in the neighbourhood. Clearly, the matrix <i>H</i>
must satisfy
</p><p>
<i>a<sub>t,s</sub>N<sub>s</sub></i> =
    (<i>h</i><sub>0,0</sub> + &hellip; + <i>h</i><sub>0,<i>n</i>&minus;1</sub>) +
    (<i>h</i><sub>1,0</sub> + &hellip; + <i>h</i><sub>1,<i>n</i>&minus;1</sub>) +
    &hellip; +
    (<i>h</i><sub><i>m</i>&minus;1,0</sub> + &hellip; +
        <i>h</i><sub><i>m</i>&minus;1,<i>n</i>&minus;1</sub>).
</p><p>
Note that during execution of the algorithm each column in the tissue will be
considered as a source column once. Therefore, we use the same
matrix <i>H</i> and the same set of spreading identifiers <i>D</i><sub>t,s</sub>
for each column in the tissue.
We can safely recycle these data for each column, because we know from the
<a href="./cellconnect.html#column_setup">previous section</a>
that all columns were set-up exactly the same way. Synapses we have to spread
thus reside at exactly the same positions <i>D</i><sub>t,s</sub> in all columns.
</p><p>
Let <i>p</i> &isin; <i>D</i><sub>t,s</sub>  be a spreading identifier of a synapse in some
source column. We show that <i>p</i> also uniquely identifies a <em>shift vector</em>
<b>w</b><sub><i>p</i></sub> from the central column of the neighbourhood
of the source column to a particular target column inside the neighbourhood.
Let <i>ord</i><sub><i>t,s</i></sub>(<i>p</i>) be the ordinal number of <i>p</i>
in <i>D</i><sub>t,s</sub> counting from zero (there is a natural total order
on <i>D</i><sub>t,s</sub>). There must exist unique indices <i>i</i> and <i>j</i>
into the matrix <i>H</i> such that
</p><p>
<!--We know from the-->
<!--<a href="./cellconnect.html#column_setup">previous section</a>-->
<!--that all columns were set-up exactly the same way. Synapses we have to spread-->
<!--amongst columns thus have exactly the same synapse identifiers (in each-->
<!--column).-->
<!--</p><p>-->
<!--It remains to say <em>how</em> we actually move synapses into target columns.-->
<!--Clearly, there is no room for them, because territories of all cells in the tissue-->
<!--are fully occupied (this was the output from the algorithm presented in the-->
<!--<a href="./cellconnect.html#column_setup">previous section</a>).-->
<!--Nevertheless, we also know from the previous section that all columns were-->
<!--set-up exactly the same way. Synapses we have to spread amongst columns thus-->
<!--have exactly the same <em>synapse identifiers</em> (see the-->
<!--<a href="./cellconnect.html#column_setup">previous section</a>).-->
<!--Synapses we have to spread amongst columns thus-->
<!--lie on exactly the same synapse identifiers (i.e. positions) within all columns.-->
<!--</p><p>-->
    <!--We can easily and-->
<!--uniquely identify each of these <i>a<sub>t,s</sub>N<sub>s</sub></i> positions-->
<!--by <em>synapse identtifiers</em> introduced in the-->
<!--<a href="./cellconnect.html#column_setup">previous section</a>-->
<!--(note that <i>a<sub>t,s</sub> &le; T<sub>s</sub></i>).-->
<!--Let <i>p</i> be a synapse identifier of any such position in the source column.-->
<!--We show that <i>p</i> also uniquely identifies the target column in the neighbourhood-->
<!--of the source column. First of all, there must exist unique indices  <i>i</i> and-->
<!--<i>j</i> into the matrix <i>H</i> such that-->
0 &le;
    <i>ord</i><sub><i>t,s</i></sub>(<i>p</i>) &minus;
        ((<i>h</i><sub>0,0</sub> + &hellip; +
            <i>h</i><sub>0,<i>n</i>&minus;1</sub>) +
        &hellip; +
        (<i>h</i><sub>i,0</sub> + &hellip; +
            <i>h</i><sub><i>i</i>&minus;1,<i>j</i>&minus;1</sub>))
    &lt;
    <i>h</i><sub>i,j</sub>.
</p><p>
From these indices we can directly compute the shift vector
</p><p>
<b>w</b><sub><i>p</i></sub> =
    (<i>i</i>&minus;&lfloor;<i>m</i>/2&rfloor;, <i>j</i>&minus;&lfloor;<i>n</i>/2&rfloor;).
</p><p>
<!--from the central column of the neighbourhood to the target column inside it.-->
Note that the position of the synapse in the target column (where we have to store
it) is <i>p</i> again.
</p><p>
We are now ready to describe the process by which we move a synapse
at a given position <i>p</i> &isin; <i>D</i><sub>t,s</sub> inside some column
<i>c</i><sub>0</sub> located at certain tissue coordinates
(<i>x</i><sub>0</sub>,<i>y</i><sub>0</sub>) into the same position <i>p</i> in
a computed target column. First we compute coordinates
(<i>x</i><sub>1</sub>,<i>y</i><sub>1</sub>) =
    <i>F</i>(<i>x</i><sub>0</sub>,<i>y</i><sub>0</sub>) + <b>w</b><sub><i>p</i></sub>
of the target column <i>c</i><sub>1</sub> for the synapse. Next we save a
synapse at the position <i>p</i> in <i>c</i><sub>1</sub> and then we write at that
position the synapse we move from <i>c</i><sub>0</sub>. Then we repeat the process
with the saved synapse. It means that we compute coordinates
(<i>x</i><sub>2</sub>,<i>y</i><sub>2</sub>) =
    <i>F</i>(<i>x</i><sub>1</sub>,<i>y</i><sub>1</sub>) + <b>w</b><sub><i>p</i></sub>
of the target column <i>c</i><sub>2</sub>. And again we save a
synapse at the position <i>p</i> in <i>c</i><sub>2</sub> and we write at that
position the synapse we saved from <i>c</i><sub>1</sub>.
We continue in this process until we either get back to the column
<i>c</i><sub>0</sub>, or we compute coordinates which lie
outside the tissue (this may only happen when at least one tissue axis
is <em>not</em> the torus axis). The described procedure is depicted in the
following picture (for the first type of termination):
</p>
<img src="./spread_synapses_exchange_scheme.svg" alt="[spread_synapses_exchange_scheme.svg]">
<p>
We see the tissue, orientation of its axes, and selected columns. In each of these
columns we see only cells of the target kind <i>t</i>. That is because we move
synapses only amongst territories of these cells. Also observe that all synapses which
we move along the dashed arrows lie at the same position
<i>p</i> &isin; <i>D</i><sub>t,s</sub> in these columns. Each dashed arrow represent
the composition of two shifts from the position of a moved
synapse. First there is a shift from a source column
at some coordinates (<i>x</i>,<i>y</i>) to a target
column at coordinates
<i>F</i>(<i>x</i>,<i>y</i>) + <b>w</b><sub><i>p</i></sub>.
And second there is the shift to the position <i>p</i> in the target column.
</p><p>
We have to ensure that synapses in all columns in the
tissue at that position <i>p</i> &isin; <i>D</i><sub>t,s</sub>
are moved. Therefore, we start the described process (with the same position
<i>p</i>) for each column in the tissue (i.e. for all coordinates
(<i>x</i>,<i>y</i>)). We, of course, skip all columns whose
synapses at the position <i>p</i> were already moved. Indeed, the process started from
some column <i>c</i><sub>0</sub> actually moves synapses of several columns
<i>c</i><sub>0</sub>, <i>c</i><sub>1</sub>, &hellip; <i>c</i><sub>k</sub>.
We can thus safely skip all columns
<i>c</i><sub>1</sub>, &hellip; <i>c</i><sub>k</sub>.
It is easy to check whether to skip a given column: We start the process from that
column only if <i>x</i> and <i>y</i> coordinates to source cell of a synapse at the
position <i>p</i> in the column are equal to the tissue coordinates of that column.
</p><p>
Now we know how to move synapses at any given position <i>p</i> &isin; <i>D</i><sub>t,s</sub>
in all columns in the tissue. There are <i>a<sub>t,s</sub>N<sub>s</sub></i> spreading
identifiers in <i>D</i><sub>t,s</sub>. So, we have to apply the process independently
for each of them.
</p><p>
The presented algorithm is implemented in files
</p>
<ul><li>
<a href="../../../code/cellconnect/include/cellconnect/spread_synapses_into_neighbourhoods.hpp">
    spread_synapses_into_neighbourhoods.hpp</a> and
</li><li>
<a href="../../../code/cellconnect/src/spread_synapses_into_neighbourhoods.cpp">
    spread_synapses_into_neighbourhoods.cpp</a>
</li></ul>
<p>
as a function <tt>spread_synapses_into_neighbourhoods</tt>. A module-private
function <tt>go_to_next_task</tt> provides simultaneous computation of positions
<i>p</i> in columns and indices <i>i</i> and <i>j</i> into the matrix <i>H</i>.
A function <tt>decompose_shift_to_synapse</tt> then decomposes <i>p</i> into
an index of a cell in a column and an index into the territory of that cell.
The decomposition is necessary for physical access to synapses in the tissue.
And a function <tt>thread_spread_synapses</tt> performs the move of synapses
at a given position <i>p</i> in all columns in the tissue.
</p><p>
Note that as we call the whole algorithm for different source and target kinds
<i>s</i> and <i>t</i>, we can always pass a different matrix <i>H</i> of different
dimensions <i>m</i>&times;<i>n</i>, and with a different column-shift function <i>F</i>.
This strategy is actually desired.
</p>
<h3 id="column_shift_function">Column-shift function</h3>
<p>
We provide and approach which is inspired in the <em>tiling plane</em>
<a href="./cellconnect.html#references">[1]</a>.
</p>
<h2 id="delimiters">Initialising delimiters of migration lists</h2>
<h2 id="references">References</h2>
<table>
    <tr><td>[1]</td><td>
        Wikipedia: List of convex uniform tilings.
        <a href="https://en.wikipedia.org/wiki/List_of_convex_uniform_tilings">
            https://en.wikipedia.org/wiki/List_of_convex_uniform_tilings</a>.
    </td></tr>
    <tr><td>[2]</td><td>
        Wikipedia: Tiling with rectangles.
        <a href="https://en.wikipedia.org/wiki/Tiling_with_rectangles">
            https://en.wikipedia.org/wiki/Tiling_with_rectangles</a>.
    </td></tr>
</table>
</body>
</html>
