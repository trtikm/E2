<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="icon" href="../../E2_icon.svg" sizes="any" type="image/svg">
<link rel="stylesheet" type="text/css" href="../../text_style.css">
<title>E2: cellconnect </title>
</head>
<body>
<h1>E2: cellconnect</h1>
<p>
This module provides algorithms which are able to <em>set-up</em> synapses between cells in
a neural tissue s.t. the resulting tissue has some desired <em>network properties</em>
[<kbd style="color:red">TODO</kbd>].
It means that here we consider a neural tissue to be a network (graph) with cells
representing nodes and synapses representing links (edges). A network property is
then any property we can tell about a network from the point of view of the graph/network
theory. Here we primarily focus on the following very important
network properties: small-world property, power-law distribution of in/out-degrees
of cells (i.e. is the network scale-free), and clustering coefficients of cells.
</p>
<h2 id="motivation">Motivation</h2>
<p>
Number of cells in a neural tissue can be quite large. An exact specification of
connections between cells requires a space comparable with the size of the tissue
itself (remember that number of synapses is dominant in any realistic tissue).
And that is not acceptable. Our goal thus is to provide an alternative
specification with the following properties:
</p>
<ul><li>
    It has negligible memory requirements compared to size of the tissue.
</li><li>
    It still allow us to specify desired network properties of the tissue.
</li><li>
    We can construct algorithms which can efficiently interconnect cells
    in the tissue according to the specification.
</li></ul>
<p>
Our solution splits the whole problem into a sequence of three sub-problems.
First, we interconnect only cells appearing in the same column. Then
we spread synapses from original cells to cells in other columns. And we
finish by setting up delimiters of migration lists for each cells in the tissue.
These three parts are described in details in the following three sections.
</p>
<p>
Remember that to interconnect a source and a target cell by a synapse equals
to setting synapse's coordinates of its source cell stored inside the territory of
the target cells. Therefore, the first two sub-problems only set coordinates
of source cells of all synapses. No other properties of synapses are neither read
nor written.
</p>
<h2 id="column_setup">Set-up of synapses in column</h2>
<p>
Each column in a neural tissue has exactly the same structure. We can thus apply
the same set-up procedure for each column independently. Clearly, it suffices
if we describe in this section only the set-up procedure for any given column.
The structure of a column (along the columnar axis) is the following.
</p>
<img class="figure"
     src="./column_and_sensory_cells.svg"
     alt="[column_and_sensory_cells.svg]">
<p>
We see <i>K</i> kinds of tissue cells. <i>i</i>-th kind has exactly
<i>N<sub>i</sub></i> cells. Each cell of <i>i</i>-th kind has a territory for exactly
<i>T<sub>i</sub></i> synapses. We further see in the picture the mapping of sensory cells
to their coordinates along the columnar axis. There are <i>S</i> kinds of sensory cells
and <i>i</i>-th kind has exactly <i>N<sub>i</sub></i> sensory cells.
</p><p>
Each synapse is associated with tissue coordinates of its source cell (projecting the axon).
Our goal is to set-up coordinates to source cells of each synapse in the territory of each cell
in the column. Note that all these coordinates may differ only in the third coordinate (i.e.
along the columnar axis).
</p><p>
Ideally we should specify for each tissue cell and each sensory cell how many synapses it
projects into what tissue cell. Nevertheless, the size of this specification depends
on the length of the columnar axis of the tissue, i.e. it can be large
(<i>C&times;C<sub>S</sub></i> records). We thus propose a different specification,
where we focus on <em>kinds</em> of cell instead of individual cells.
Namely, for each kind of tissue cells
0 &le; <i>i</i> &lt; <i>K</i>
and for each kind of tissue or sensory cells
0 &le; <i>j</i> &lt; <i>K</i>+<i>S</i>
we specify a number of synapses
<i>a<sub>i,j</sub></i>
which are projected from <em>each</em> cell of the kind <i>j</i> to
<em>each</em> cell of the kind <i>i</i>. We can put all the numbers
<i>a<sub>i,j</sub></i>
into a matrix <i>A</i> of dimensions <i>K</i>&times;(<i>K</i>+<i>S</i>):
</p>
<img class="figure"
     src="./column_fill_matrix.svg"
     alt="[column_fill_matrix.svg]">
<p>
For each
0 &le; <i>i</i> &lt; <i>K</i>
the matrix <i>A</i> must satisfy
<i>T<sub>i</sub>N<sub>i</sub></i> =
(<i>a</i><sub><i>i</i>,0</sub><i>N</i><sub>0</sub> + &hellip; +
<i>a</i><sub><i>i,i</i></sub><i>N</i><sub><i>i</i></sub> + &hellip; +
<i>a</i><sub><i>i,K</i>&minus;1</sub><i>N</i><sub><i>K</i>&minus;1</sub>) +
(<i>a</i><sub><i>i,K</i></sub><i>N</i><sub><i>K</i></sub> + &hellip; +
<i>a</i><sub><i>i</i>,<i>K+S</i>&minus;1</sub><i>N</i><sub><i>K+S</i>&minus;1</sub>).
</p><p>
Let <i>i</i> be a kind of tissue cells (i.e. 0 &le; <i>i</i> &lt; <i>K</i>),
<i>j</i> be an index of some tissue cell of the kind <i>i</i> (i.e.
0 &le; <i>j</i> &lt; <i>N<sub>i</sub></i>), and <i>k</i> be an index of a synapse
in the territory of the <i>j</i>-th cell of the kind <i>i</i> (i.e.
0 &le; <i>k</i> &lt; <i>T<sub>i</sub></i>). Then the number
<i>k</i><i>N</i><sub><i>i</i></sub> + <i>j</i>
is a <i>columnar identifier</i> of the synapse at the <i>k</i>-th index in
the territory of the <i>j</i>-th cell of the kind <i>i</i>.
In the following picture we can see a graphical representation of columnar identifiers
of synapses.
</p>
<img class="figure"
     src="./columnar_identifiers_of_synapses.svg"
     alt="[columnar_identifiers_of_synapses.svg]">
<p>
Let us denote a columnar coordinate of a the <i>j</i>-th cell of either tissue or sensory
cell kind <i>i</i> (i.e.
0 &le; <i>j</i> &lt; <i>N<sub>i</sub></i>, 0 &le; <i>i</i> &lt; <i>K</i>+<i>S</i>)
as <i>c</i><sub><i>i</i>:<i>j</i></sub>. Clearly,
<i>c</i><sub><i>i</i>:<i>j</i></sub> =
    <i>T</i><sub>0</sub><i>N</i><sub>0</sub> +
    &hellip; +
    <i>T</i><sub><i>i</i>&minus;1</sub><i>N</i><sub><i>i</i>&minus;1</sub> + <i>j</i>.
</p><p>
Let us consider a synapse with a columnar identifier <i>k</i> in the territory of
a tissue cell of a kind <i>i</i>. If (<i>x</i>,<i>y</i>) are tissue coordinates
of the considered column, then the procedure sets-up coordinates of the source cell of that
synapse as (<i>x</i>,<i>y</i>,<i>c</i><sub><i>j</i>:<i>l</i></sub>), where <i>j</i>
and <i>l</i> mean the following. The cell kind <i>j</i> is a unique index of
a column in the matrix <i>A</i> satisfying
0 &le; <i>k</i> &minus; (<i>a</i><sub><i>i</i>,0</sub><i>N</i><sub>0</sub> + &hellip; +
    <i>a</i><sub><i>i</i>,<i>j</i>&minus;1</sub><i>N</i><sub><i>j</i>&minus;1</sub>)
    &lt; <i>a</i><sub><i>i</i>,<i>j</i></sub><i>N</i><sub><i>j</i></sub>.
The cell index <i>l</i> is then a unique value
&lfloor;(<i>k</i> &minus; (<i>a</i><sub><i>i</i>,0</sub><i>N</i><sub>0</sub> + &hellip; +
    <i>a</i><sub><i>i</i>,<i>j</i>&minus;1</sub><i>N</i><sub><i>j</i>&minus;1</sub>))
    / <i>a</i><sub><i>i</i>,<i>j</i></sub>&rfloor;.
</p><p>
We are ready to describe whole the procedure. It iterates over tissue kinds
<i>i</i>=0,&hellip;,<i>K</i>&minus;1. For each kind <i>i</i> it performs two
iterations simultaneously. First, it iterates over all synapse identifiers
<i>k</i>=0,&hellip;,<i>T</i><sub><i>i</i></sub><i>N</i><sub><i>i</i></sub>&minus;1
referencing to territories of tissue cells of the kind <i>i</i>.
And second, it iterates the <i>i</i>-th row in the matrix <i>A</i> such that
it incrementally approaches to the sum
<i>a</i><sub><i>i</i>,0</sub><i>N</i><sub>0</sub> + &hellip; +
    <i>a</i><sub><i>i</i>,<i>K+S</i>&minus;1</sub><i>N</i><sub><i>K+S</i>&minus;1</sub>.
This iteration allows the procedure to directly obtain the columnar coordinate
<i>c</i><sub><i>j</i>:<i>l</i></sub> for the corresponding synapse identifier <i>k</i>
(c.f. the sum with the expressions used in the computation of numbers <i>j</i>
and <i>l</i>). We iterate in both sequences synchronously. Observe that both
sequences have exacty the same size.
</p><p>
The algorithm which sets-up all columns in the tissue (each column exactly the
same way) according to the matrix <i>A</i> is implemented in files
</p>
<ul><li>
    <a href="../../../code/cellconnect/include/cellconnect/fill_coords_of_source_cells_of_synapses_in_tissue.hpp">
        fill_coords_of_source_cells_of_synapses_in_tissue.hpp</a> and
</li><li>
    <a href="../../../code/cellconnect/src/fill_coords_of_source_cells_of_synapses_in_tissue.cpp">
        fill_coords_of_source_cells_of_synapses_in_tissue.cpp</a>
</li></ul>
<p>
as a function <kbd>fill_coords_of_source_cells_of_synapses_in_tissue</kbd>.
</p><p>
The algorithm accepts (besides the matrix <i>A</i>) a number of threads available
for the computation. This number determines how many columns will be set-up simultaneously.
The described procedure for the set-up of a single given column is implemented in that
<kbd>cpp</kbd> file as a function
<kbd>fill_coords_of_source_cells_of_synapses_in_single_column</kbd>.
</p>
<h2 id="spreading_synapses">Spreading synapses amongst columns</h2>
<p>
It is sufficient to provide an algorithm which spreads synapses only between
tissue cells of a given source kind <i>s</i> and a target kind <i>t</i>. The algorithm
can then be called several times, for each pair of a source and target kinds we need.
</p><p>
First we have to specify <em>where</em> we move synapses from their original places.
We do so in terms of whole columns (i.e. <em>not</em> per cell nor even per synapse).
For each column in the tissue we define its <em>neighbourhood</em>. A neighbourhood
is simply a rectangular region in the tissue spanning over <i>m</i> columns along
<i>X</i> axis and <i>n</i> columns along <i>Y</i> axis.
In order to ensure an existence of the central column in a neighbourhood we always
assume that both <i>m</i> and <i>n</i> are odd numbers greater than 1. Neighbourhoods
of all columns have the same fixed dimensions
<i>m</i>&times;<i>n</i>. Nevertheless, for each column we define its own shift vector
from the column to the central column of its neighbourhood. We specify these shift
vectors using a so called <em>column-shift function</em> <i>F</i>. It accepts tissue coordinates
of a column and it returns tissue coordinates of the central column of the neighbourhood.
We postpone a detailed description of <i>F</i> to a
<a href="./cellconnect.html#column_shift_function">separate section</a>
below. The left part of the following picture provides a graphical representation
of the described notion of columns' neighbourhoods.
</p>
<img class="figure"
     src="./spread_synapses_top_view.svg"
     alt="[spread_synapses_top_view.svg]">
<p>
We see the source column at tissue coordinates (<i>x,y</i>). The column-shift
function <i>F</i> maps the source column into the central column in its
neighbourhood. The neighbourhood forms a rectangle of <i>m</i>&times;<i>n</i>
target columns.
</p><p>
The algorithm is supposed to spread synapses from the source column into target columns.
We know exactly what synapses to move. It is each synapse in the territory
of any cell of the kind <i>t</i> whose coordinates of the source cell identify
a tissue cell of the kind <i>s</i>. Each of these synapses is uniquely identified by
its synapse identifier (see the
<a href="./cellconnect.html#column_setup">previous section</a>).
Let us denote a set of these synapse identifiers as <em>spreading identifiers</em>
<i>D</i><sub><i>s,t</i></sub>. We further know the exact count of those synapses
(i.e. the size of the set <i>D</i><sub><i>s,t</i></sub>). We remember from the
<a href="./cellconnect.html#column_setup">previous section</a>
(namely from the matrix <i>A</i>) that tissue cells of the target kind <i>t</i> have
together in their territories exactly <i>a<sub>t,s</sub></i> synapses from each tissue
cell of the source kind <i>s</i>. Since there is exactly <i>N<sub>s</sub></i> tissue
cells of the source kind <i>s</i>, we thus have to spread exactly
<i>a<sub>t,s</sub>N<sub>s</sub></i> synapses. Now appears a question
how we distribute all those <i>a<sub>t,s</sub>N<sub>s</sub></i> synapses (whose
positions in the source column are defined by the spreading identifiers
<i>D</i><sub><i>s,t</i></sub>) into <i>m</i>&times;<i>n</i>
columns in the neighbourhood. We specify this distribution using a matrix <i>H</i>
depicted on the right part of the picture. Observe the direct correspondence between
elements of the matrix and columns in the neighbourhood. Clearly, the matrix <i>H</i>
must satisfy
</p><p>
<i>a<sub>t,s</sub>N<sub>s</sub></i> =
    (<i>h</i><sub>0,0</sub> + &hellip; + <i>h</i><sub>0,<i>n</i>&minus;1</sub>) +
    (<i>h</i><sub>1,0</sub> + &hellip; + <i>h</i><sub>1,<i>n</i>&minus;1</sub>) +
    &hellip; +
    (<i>h</i><sub><i>m</i>&minus;1,0</sub> + &hellip; +
        <i>h</i><sub><i>m</i>&minus;1,<i>n</i>&minus;1</sub>).
</p><p>
Note that during execution of the algorithm each column in the tissue will be
considered as a source column. Therefore, we use the same matrix <i>H</i>
and the same set of spreading identifiers <i>D</i><sub>t,s</sub>
for each column in the tissue.
We can safely recycle these data for each column, because we know from the
<a href="./cellconnect.html#column_setup">previous section</a>
that all columns were set-up exactly the same way. Synapses we have to spread
thus reside at exactly the same positions <i>D</i><sub>t,s</sub> in all columns.
</p><p>
Let <i>p</i> &isin; <i>D</i><sub>t,s</sub>  be a spreading identifier of a synapse in some
source column. We show that <i>p</i> also uniquely identifies a <em>shift vector</em>
<b><i>w</i></b><sub><i>p</i></sub> from the central column of the neighbourhood
of the source column to a particular target column inside the neighbourhood.
Let <i>ord</i><sub><i>t,s</i></sub>(<i>p</i>) be the ordinal number of <i>p</i>
in <i>D</i><sub>t,s</sub> counting from zero (there is a natural total order
on <i>D</i><sub>t,s</sub>). There must exist unique indices <i>i</i> and <i>j</i>
into the matrix <i>H</i> such that
</p><p>
0 &le;
    <i>ord</i><sub><i>t,s</i></sub>(<i>p</i>) &minus;
        ((<i>h</i><sub>0,0</sub> + &hellip; +
            <i>h</i><sub>0,<i>n</i>&minus;1</sub>) +
        &hellip; +
        (<i>h</i><sub>i,0</sub> + &hellip; +
            <i>h</i><sub><i>i</i>&minus;1,<i>j</i>&minus;1</sub>))
    &lt;
    <i>h</i><sub>i,j</sub>.
</p><p>
From these indices we can directly compute the shift vector
</p><p>
<b><i>w</i></b><sub><i>p</i></sub> =
    (<i>i</i>&minus;&lfloor;<i>m</i>/2&rfloor;, <i>j</i>&minus;&lfloor;<i>n</i>/2&rfloor;).
</p><p>
We are now ready to describe the process by which we move a synapse
at a given spreading identifier <i>p</i> &isin; <i>D</i><sub>t,s</sub> inside
some column <i>c</i><sub>0</sub> located at certain tissue coordinates
(<i>x</i><sub>0</sub>,<i>y</i><sub>0</sub>) into the same spreading
identifier <i>p</i> in a computed target column. First we compute coordinates
(<i>x</i><sub>1</sub>,<i>y</i><sub>1</sub>) =
    <i>F</i>(<i>x</i><sub>0</sub>,<i>y</i><sub>0</sub>) + <b><i>w</i></b><sub><i>p</i></sub>
of the target column <i>c</i><sub>1</sub> for the synapse. Next we save a
synapse at the spreading identifier <i>p</i> in <i>c</i><sub>1</sub> and then
we write at that spreading identifier the synapse we move from <i>c</i><sub>0</sub>.
Then we repeat the process with the saved synapse. It means that we compute coordinates
(<i>x</i><sub>2</sub>,<i>y</i><sub>2</sub>) =
    <i>F</i>(<i>x</i><sub>1</sub>,<i>y</i><sub>1</sub>) + <b><i>w</i></b><sub><i>p</i></sub>
of the target column <i>c</i><sub>2</sub>. And again we save a
synapse at the spreading identifier <i>p</i> in <i>c</i><sub>2</sub> and we write at that
spreading identifier the synapse we saved from <i>c</i><sub>1</sub>.
We continue in this process until we either get back to the column
<i>c</i><sub>0</sub>, or we compute tissue coordinates which lie
outside the tissue (this may only happen when at least one tissue axis
is <em>not</em> the torus axis). The described procedure is depicted in the
following picture (for the first type of termination):
</p>
<img class="figure"
     src="./spread_synapses_exchange_scheme.svg"
     alt="[spread_synapses_exchange_scheme.svg]">
<p>
We see the tissue, orientation of its axes, and selected columns. In each of these
columns we see only cells of the target kind <i>t</i>. That is because we move
synapses only amongst territories of these cells. Also observe that all synapses which
we move along the dashed arrows lie at the same spreading identifier
<i>p</i> &isin; <i>D</i><sub>t,s</sub> in these columns. Each dashed arrow represent
the composition of two shifts from the spreading identifier of a moved
synapse. First there is a shift from a source column
at some coordinates (<i>x</i>,<i>y</i>) to a target
column at coordinates
<i>F</i>(<i>x</i>,<i>y</i>) + <b><i>w</i></b><sub><i>p</i></sub>.
And second there is the shift to the same spreading identifier <i>p</i> in the
target column.
</p><p>
We have to ensure that synapses in all columns in the tissue at that spreading
identifier <i>p</i> &isin; <i>D</i><sub>t,s</sub> are moved. Therefore, we start
the described process (with the same spreading identifier
<i>p</i>) for each column in the tissue (i.e. for all coordinates
(<i>x</i>,<i>y</i>)). We, of course, skip all columns whose synapses at the
spreading identifier <i>p</i> were already moved. Indeed, the process started from
some column <i>c</i><sub>0</sub> actually moves synapses of several columns
<i>c</i><sub>0</sub>, <i>c</i><sub>1</sub>, &hellip; <i>c</i><sub>k</sub>.
We can thus safely skip all columns
<i>c</i><sub>1</sub>, &hellip; <i>c</i><sub>k</sub>.
It is easy to check whether to skip a given column: We start the process from that
column only if <i>x</i> and <i>y</i> coordinates of a source cell of the synapse at the
spreading identifier <i>p</i> in the column are equal to the tissue coordinates of
that column.
</p><p>
Now we know how to move synapses at any given spreading identifier
<i>p</i> &isin; <i>D</i><sub>t,s</sub>
in all columns in the tissue. There are <i>a<sub>t,s</sub>N<sub>s</sub></i> spreading
identifiers in <i>D</i><sub>t,s</sub>. So, we have to apply the process independently
for each of them.
</p><p>
The presented algorithm is implemented in files
</p>
<ul><li>
<a href="../../../code/cellconnect/include/cellconnect/spread_synapses_into_neighbourhoods.hpp">
    spread_synapses_into_neighbourhoods.hpp</a> and
</li><li>
<a href="../../../code/cellconnect/src/spread_synapses_into_neighbourhoods.cpp">
    spread_synapses_into_neighbourhoods.cpp</a>
</li></ul>
<p>
as a function <kbd>spread_synapses_into_neighbourhoods</kbd>. A module-private
function <kbd>go_to_next_task</kbd> provides simultaneous computation of spreading
identifiers <i>p</i> in columns and indices <i>i</i> and <i>j</i> into the matrix
<i>H</i>. A function <kbd>decompose_shift_to_synapse</kbd> then decomposes <i>p</i>
into an index of a cell in a column and an index of the synapse in the territory of
that cell. The decomposition is necessary for physical access to synapses in the tissue.
And a function <kbd>thread_spread_synapses</kbd> performs spreading of synapses
for a given fixed spreading identifier <i>p</i> in all columns in the tissue.
</p><p>
Note that as we call the whole algorithm for different source and target kinds
<i>s</i> and <i>t</i>, we can always pass a different matrix <i>H</i> of different
dimensions <i>m</i>&times;<i>n</i>, and with a different column-shift function <i>F</i>.
This strategy is actually desired.
</p>
<h3 id="column_shift_function">Column-shift function</h3>
<p>
Let us consider a neural tissue with <i>X</i> columns along the <i>X</i> axis
and <i>Y</i> columns along the <i>Y</i> axis. Then a <em>column shift function</em>
<i>F</i> is any bijection on the set
{0,&hellip;,<i>X</i>&minus;1}&times;{0,&hellip;,<i>Y</i>&minus;1}.
We first clarify the notion of a column shift function on the following four
examples:
</p>
<img class="figure"
     src="./column_shift_function_examples.svg"
     alt="[column_shift_function_examples.svg]">
<p>
In each of the examples we see the same tiny neural tissue. It has four columns
along <i>X</i> axis and three columns along <i>Y</i> axis. We see the same
orientation of the axes in all examples (the same top view to the tissue).
Each of these examples shows a possible column shift function for the tissue.
The functions are depicted by arrows (mappings of coordinates of individual columns).
In the example (a) the column shift function is obviously identity (i.e. coordinates
of each column are mapped to itself). In the example (b) arrows form two cyclic
paths. In the example (c) arrows form four cyclic paths. And arrows in the example
(d) form a single cyclic paths spanning over all columns. In general, a column
shift function <i>F</i> is always formed by one or more cyclic paths. The minimal
count is 1 and the maximal is <i>X</i>&middot;<i>Y</i>.
</p><p>
The primary goal of this section is to provide a specification of a column
shift function for a large neural tissue. On one hand, the specification
must be considerably smaller than the tissue (i.e. size of the specification
should not depend on tissue dimensions). On the other hand,
it has to be flexible enough to allow us a construction of neural tissues
with desired network properties (small-world property, power-law distribution
of degrees, clustering coefficients).
</p><p>
We can use the explicit specification of a column shift function (i.e. by a list
of all its arrows) whenever counts of columns along <i>X</i> and <i>Y</i>
axes are quite small (usually not exceeding 100 columns). Therefore, we express
a column shift function <i>F</i> for a given large neural tissue in terms of
several considerably smaller column shift functions
<i>F</i><sub>0</sub>,&hellip;<i>F</i><sub><i>N</i>&minus;1</sub>
called <em>templates</em>. Templates may differ in definitions of their arrows
and also in counts of columns their along <i>X</i> and <i>Y</i> axes.
Once we have all <i>N</i> templates prepared, we define the column
shift function <i>F</i> such that we map each template into several concrete areas
in the large tissue. We are supposed to cover whole the tissue by templates
without any gaps or overlaps. This process is inspired by the problem of
<em>tiling plane</em>
[<a href="./cellconnect.html#r01">1</a>,<a
    href="./cellconnect.html#r02">2</a>].
We first explain basic features of the proposed specification on an example. Then
we add a description of two more features necessary for sufficient expressivity
of the specification.
</p>
<img class="figure"
     src="./templates_tiling_intuition_example.svg"
     alt="[templates_tiling_intuition_example.svg]">
<p>
We see in the picture that the specification (on the left) of the column
shift function <i>F</i> (on the right) consists of six templates
<i>F</i><sub>0</sub>, <i>F</i><sub>1</sub>, <i>F</i><sub>2</sub>,
<i>F</i><sub>3</sub>, <i>F</i><sub>4</sub>, <i>F</i><sub>5</sub>,
a <em>layout matrix</em> <i>L</i>, and two <em>repetition lists</em>
<i>R</i><sub><i>X</i></sub> and <i>R</i><sub><i>Y</i></sub>.
Elements of the layout matrix are indices of individual templates. A position of
an index in the matrix correspond to a concrete region in <i>F</i> where the
template (with that index) is mapped onto. But, we cannot see the correspondence directly,
because the layout matrix <i>L</i> is actually compressed. We thus also need the
repetition lists <i>R</i><sub><i>X</i></sub> and <i>R</i><sub><i>Y</i></sub>.
Their elements specify what rows and columns of <i>L</i> have to be repeated
how many time in order to get the uncompressed version of <i>L</i>. Namely,
each triple <i>b</i>:<i>e</i>:<i>n</i> in <i>R</i><sub><i>X</i></sub> specifies
that a block of rows <i>b</i>,<i>b</i>+1,&hellip;,<i>e</i>&minus;1 in <i>L</i>
is repeated exactly <i>n</i> times in the uncompressed <i>L</i>.
Triples in <i>R</i><sub><i>Y</i></sub> have similar meaning; they specify
repetitions of blocks of columns. For example, the first triple 0:1:1 of
<i>R</i><sub><i>X</i></sub> says that the first row of <i>L</i> is repeated once.
The second triple 1:3:2 says that the second and third row are repeated twice
(as a single block of two rows). And the last triple defines a single repetition
of the fourth row. If we apply this process also for elements of
<i>R</i><sub><i>Y</i></sub>, then we receive the following uncompressed matrix:
</p>
<img class="figure"
     src="./templates_tiling_intuition_example_decompressed_L.svg"
     alt="[templates_tiling_intuition_example_decompressed_L.svg]">
<p>
Now we can see the direct correspondence between elements of this matrix and
regions in <i>F</i>; the regions are separated by dotted lines. For example,
the leftmost column in the matrix maps templates
<i>F</i><sub>0</sub>, <i>F</i><sub>1</sub>, <i>F</i><sub>4</sub>,
    <i>F</i><sub>1</sub>, <i>F</i><sub>4</sub>, <i>F</i><sub>0</sub>
into the leftmost column of regions in <i>F</i>. Observe that regions in
<i>F</i> are always rectangular, just like the templates. Moreover,
all regions inside a single row of regions in <i>F</i> always
have the same number of tissue columns along <i>X</i> axis (i.e. they have
the same dimension along <i>X</i> axis). And similarly, all regions inside
a single column of regions always have the same number of tissue columns
along <i>Y</i> axis.
</p><p>
The compression of <i>L</i> is necessary, because dimensions of the uncompressed
version grow with dimensions of the tissue. The compression allows for expansion
to larger tissues simply by increasing the third components of triples
in the lists <i>R</i><sub><i>X</i></sub> and <i>R</i><sub><i>Y</i></sub>.
It should be clear at this point that a computation of <i>F</i>((<i>x</i>,<i>y</i>))
for any given coordinates (<i>x</i>,<i>y</i>) must always be performed
on a compressed specification.
</p><p>
Now we focus on improvements of the expressivity of the proposed specification.
The specification currently maps templates to completely isolated regions of
<i>F</i>. We remove this limitation such that we extend the specification of
templates by <em>external arrows</em>. Once a template is mapped to a certain
region in the tissue its external arrows define interconnection of its tissue
columns with tissue columns inside regions in its direct neighbourhood.
The idea is depicted in the following picture.
</p>
<img class="figure"
     src="./templates_interconnection_intuition.svg"
     alt="[templates_interconnection_intuition.svg]">
<p>
On the left we see a template with external arrows. These arrows are depicted as
black triangles annotated by numbers. An orientation of an external arrow determines
its kind. If it points to the interior of its tissue column, then the column is the target
of a regular arrow coming from a region in its neighbourhood. If it points from the
interior of its tissue column, then the column is the source of a regular arrow coming
from this region to its neighbourhood. In both cases an orientation of an external
arrow determines a concrete region in the neighbourhood and its annotation number
determined a concrete tissue column in that region. For example, a tissue column
in the centre of the template has two external arrows. One points into the tissue column
from the left and it is annotated by the number 1. The second external arrow points from
the the column's interior downwards and it is annotated by the number 0. So, the tissue
column is a target of a regular arrow coming from the region on the left (at lower
<i>Y</i> coordinates), and it is also a source column of a regular arrow going into
the region bellow (at higher <i>X</i> coordinates).
</p><p>
The right part of the picture shows how external arrows are replaced by regular ones
when the template is are mapped onto a region. We see that our template (left) is mapped
onto the region in the middle of the depicted tissue (right). This region is
surrounded by eight other regions forming its direct neighbourhood. Note that
we show only those tissue columns of regions in the neighbourhood which are important
in the discussed topic (i.e. the representation of external arrows). Let us describe how
we compute arrows for the tissue column in the middle of the central region. The
external arrow number 1 specifies a regular arrow coming from the region on the
left in the neighbourhood, namely from a tissue column with an external arrow
labelled by the same number 1 pointing from the column's interior to the right.
Similarly, the second external arrow with the number 0 specifies a regular arrow going
to the region bellow in the neighbourhood, namely to a tissue column with the same
number 0 pointing to the column's interior from the top. Remaining regular
arrows in the picture are set in the same way.
</p><p>
External arrows in the example above used only four orientations (left, right,
top, and down). In fact, we also allow the remaining four diagonal orientations.
A tissue column in a region thus can be interconnected with any of eight
regions in its direct neighbourhood.
</p><p>
The second improvement of the specification allows for establishing the small
world property. We assume in the specification that dimensions of all templates
are incomparably smaller than dimensions of a resulting column shift function.
Therefore, the column shift function <i>F</i> is divided into large number of regions
(where individual templates are mapped onto). Since the specification only allows for
interconnection of tissue columns in directly adjacent regions, the small world property
(i.e. the longest of all shortest paths in the network between any two cells) can be quite
long. The goal of this improvement is to allow scaling of templates. When templates
are mapped into larger regions (due to their scaling), the column shift function
can be divided into lower count of these regions. We explain the scaling in two
steps. First we explain the basics, where we ignore external arrows. Then we
complete the description by including external arrows.
</p>
<img class="figure"
     src="./templates_scaling.svg"
     alt="[templates_scaling.svg]">
<p>
On the left we see a template (it is the same template as in the previous picture)
and on the right there is depicted a region in a column shift function, where the
template is mapped to. Observe that each tissue column in the template is mapped
into a block of 2&times;2 columns inside the region. Blocks are highlighted by
dashed rectangles. The mapping is straightforward. For example, the left-top tissue
column in the template is mapped to the left-top block in the region. The common dimensions
of all blocks determine the scale of the template. Namely, a scale <i>S</i><sub><i>X</i></sub>
of the template along the <i>X</i> axis is 2. And a scale <i>S</i><sub><i>Y</i></sub>
of the template along the <i>Y</i> axis is also 2. Of course, scales
<i>S</i><sub><i>X</i></sub> and <i>S</i><sub><i>Y</i></sub> may differ in general.
A regular arrow between any two tissue columns in the template represents
exactly <i>S</i><sub><i>X</i></sub>&middot;<i>S</i><sub><i>Y</i></sub> regular arrows
between tissue columns inside two blocks (of dimensions
<i>S</i><sub><i>X</i></sub>&times;<i>S</i><sub><i>Y</i></sub>) corresponding to the
two tissue columns of the arrow in the template. Arrows between tissue columns of the
blocks always connect tissue columns appearing at exactly the same positions
in the blocks. For example, the regular arrow in the template going from the left-bottom
tissue column to the right-bottom column represents four regular arrows in the region
going from tissue columns of the left-bottom block to the right-bottom block. Observe
that arrows indeed always connect tissue columns at exactly the same positions in both
blocks (from the left-top column to the left-top column, from the right-top to the right-top,
from the left-bottom to the left-bottom, and from the right-bottom to the right-bottom).
You can check that all remaining regular arrows in the template are represented the same
way in the region.
</p><p>
It remains to discuss how we represent external arrows of the template in the column
shift function. Our intention is to use the same representation as for regular arrows.
Since each external arrow always references a region in the neighbourhood (of the region
where the template is mapped), we have to ensure that dimensions of blocks in all regions
in the neighbourhood are exactly the same. The simples way how to ensure this is to define
common scales <i>S</i><sub><i>X</i></sub> and <i>S</i><sub><i>Y</i></sub> for all
templates. In the following picture we show representation of both regular and external arrows
of the template above in the corresponding region and its neighbourhood. The common scales
for all templates are <i>S</i><sub><i>X</i></sub>=2 and <i>S</i><sub><i>Y</i></sub>=2.
Due to clarity of the picture we show only arrows between tissue columns appearing at the
left-top positions in blocks. Arrows at the remaining three positions in blocks can be obtained
by simultaneous shift of all depicted arrows one column right or down, or in both directions.
Observe that this picture is a scaled version of the example we used for the explanation of
external arrows.
</p>
<img class="figure"
     src="./templates_interconnection_scaled.svg"
     alt="[templates_interconnection_scaled.svg]">
<p>
Now we are ready to give a complete specification of a column shift function. It consists
of <i>N</i> templates with external arrows, a layout matrix <i>L</i>, repetition lists
<i>R</i><sub><i>X</i></sub> and <i>R</i><sub><i>Y</i></sub>, and a common scales for all
templates <i>S</i><sub><i>X</i></sub> and <i>S</i><sub><i>Y</i></sub>. It is required that
regions onto which scaled templates are mapped cover all columns of the tissue without any
gaps or overlaps. Moreover, external arrows of templates must be established in such a way
that they all can be transformed to regular arrows (according to the process described
above) when the templates are mapped to proper regions in the tissue. A complete version
of the specification we presented at the beginning of this section may look as follows.
</p>
<img class="figure"
     src="./templates_interconnection.svg"
     alt="[templates_interconnection.svg]">
<p>
The presented specification of a column sift function is implemented in files
</p>
<ul><li>
<a href="../../../code/cellconnect/include/cellconnect/column_shift_function.hpp">
    column_shift_function.hpp</a> and
</li><li>
<a href="../../../code/cellconnect/src/column_shift_function.cpp">
    column_shift_function.cpp</a>.
</li></ul>
<p>
A template is defined as <kbd>struct shift_template</kbd>, a layout matrix as
<kbd>struct layout_of_shift_templates</kbd>, a triple in a repetition list as
<kbd>struct repetition_block</kbd>, and the algorithm for a computation of
<i>F</i>((<i>x</i>,<i>y</i>)) for any given coordinates (<i>x</i>,<i>y</i>)
using a compressed specification is implemented as
<kbd>column_shift_function::operator()</kbd>. Note that we intentionally omitted
a description of the computation <i>F</i>((<i>x</i>,<i>y</i>)) here, because the
code of the operator is self-explanatory with the knowledge we received here.
</p>
<h2 id="delimiters">Initialising delimiters of migration lists</h2>
<p>
If the territory of a tissue cell of a kind <i>i</i> has the capacity for
<i>T</i><sub><i>i</i></sub> synapses, then this algorithm sets a
<i>j</i>-th delimiter (<i>j</i> &isin; {0,&hellip;5}) to the value
&lfloor;<i>T</i><sub><i>i</i></sub> / 6&rfloor;.
</p><p>
The algorithm is implemented in files
</p>
<ul><li>
<a href="../../../code/cellconnect/include/cellconnect/fill_delimiters_between_territorial_lists.hpp">
    fill_delimiters_between_territorial_lists.hpp</a> and
</li><li>
<a href="../../../code/cellconnect/src/fill_delimiters_between_territorial_lists.cpp">
    fill_delimiters_between_territorial_lists.cpp</a>.
</li></ul>
<p>
<h2 id="references">References</h2>
<table>
    <tr><td id="r01">[1]</td><td>
        Wikipedia: List of convex uniform tilings.
        <a href="https://en.wikipedia.org/wiki/List_of_convex_uniform_tilings">
            https://en.wikipedia.org/wiki/List_of_convex_uniform_tilings</a>.
    </td></tr>
    <tr><td id="r02">[2]</td><td>
        Wikipedia: Tiling with rectangles.
        <a href="https://en.wikipedia.org/wiki/Tiling_with_rectangles">
            https://en.wikipedia.org/wiki/Tiling_with_rectangles</a>.
    </td></tr>
</table>
</body>
</html>
