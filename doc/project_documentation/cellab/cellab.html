<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="icon" href="../../E2_icon.svg" sizes="any" type="image/svg">
<link rel="stylesheet" type="text/css" href="../../text_style.css">
<title>E2: cellab </title>
</head>
<body>
<h1>E2: cellab</h1>
<p>
<!--<kbd style="color:red">TODO</kbd>-->
This library defines a parametrised model of a mammalian cerebral cortex
[<a href="./cellab.html#r01">1</a>] called a <em>neural tissue</em> in the whole E2
project. Instances of the model (for given parameters) are primary subjects of the
study. A <em>parameter</em> of the neural tissue is any datum passed
to any library function constructing the model in the memory or any algorithm
passed to any library function performing a simulation step.
</p><p>
The neural tissue consists of two parts: <em>data structures</em> defining how
state is stored in the memory, and <em>transition algorithms</em> allowing
a computation of a next state from the current one. We describe these two parts
in the following three sections. Namely, in
<a href="./cellab.html#neural_tissue">section 1</a>
we discuss the data structure of the neural tissue. In
<a href="./cellab.html#memory_representation">section 2</a>
we describe how data are physically stored in the memory.
And in
<a href="./cellab.html#transition_algorithms">section 3</a>
we describe transition algorithms.
</p><p>
The library further provides a data type for aggregation of the neural tissue
with its parametrisation. We discuss it in
<a href="./cellab.html#aggregation_with_parametrisation">section 4</a>.
</p>
<h2 id="neural_tissue">1.&nbsp;&nbsp;&nbsp;Structure of neural tissue</h2>
<p>
A state of the neural tissue is stored in two data structures: <em>static state</em>
and <em>dynamic state</em>. While the static state holds all data which remain constant
during the whole simulation, the dynamic state holds all data which can be modified
during the simulation.
</p>
<h3 id="static_state">1.1&nbsp;&nbsp;&nbsp;Static state</h3>
<p>
It is a storage of global immutable properties of the neural tissue. The properties
are specified by a parametrisation (so they are actually parameters). In the table
below we list the properties with their brief descriptions. We complete the descriptions
in the
<a href="./cellab.html#dynamic_state">next section</a>
where we will see the properties in the context of the dynamic state.
</p>
<table class="enumerate">
<tr>
<th align="right">Property</th>
<th>&nbsp;&nbsp;&nbsp;</th>
<th align="left">Description</th>
</tr>
<tr><td align="right" valign="top">
<i>K</i>
</td><td></td><td align="left" valign="top">
A number of kinds of territories in the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>S</i>
</td><td></td><td align="left" valign="top">
A number of kinds of sensory cells.
</td></tr>
<tr><td align="right" valign="top">
<i>U</i>
</td><td></td><td align="left" valign="top">
A number of kinds of synapses to muscles.
</td></tr>
<tr><td align="right" valign="top">
[<i>N</i><sub>0</sub>,&hellip;,<i>N</i><sub><i>K</i>&minus;1</sub>]
</td><td></td><td align="left" valign="top">
An array of <i>K</i> numbers, where <i>N</i><sub><i>i</i></sub>
is a count of tissue cells of the kind
<i>i</i>.
</td></tr>
<tr><td align="right" valign="top">
[<i>N</i><sub><i>K</i></sub>,&hellip;,<i>N</i><sub><i>K</i>+<i>S</i>&minus;1</sub>]
</td><td></td><td align="left" valign="top">
An array of <i>S</i> numbers, where <i>N</i><sub><i>i</i></sub>
is a count of sensory cells of the kind
<i>i</i>&minus;<i>K</i>.
</td></tr>
<tr><td align="right" valign="top">
[<i>M</i><sub>0</sub>,&hellip;,<i>M</i><sub><i>U</i>&minus;1</sub>]
</td><td></td><td align="left" valign="top">
An array of <i>U</i> numbers, where <i>M</i><sub><i>i</i></sub>
is a count of synapses to muscles of the kind
<i>i</i>.
</td></tr>
<tr><td align="right" valign="top">
[<i>T</i><sub>0</sub>,&hellip;,<i>T</i><sub><i>K</i>&minus;1</sub>]
</td><td></td><td align="left" valign="top">
An array of <i>K</i> numbers, where <i>T</i><sub><i>i</i></sub>
is a count of elements in all three territorial lists <i>LS</i>, <i>LT</i>,
and <i>LC</i> (see the lists
<a href="./cellab.html#territorial_lists">here</a>)
in any territory of the kind <i>i</i>.
</td></tr>
<tr><td align="right" valign="top">
<i>N</i><sub>S</sub>
</td><td></td><td align="left" valign="top">
A total number of sensory cells, i.e.
<i>N</i><sub>S</sub> =
    <i>N</i><sub><i>K</i></sub>+&hellip;+<i>N</i><sub><i>K</i>+<i>S</i>&minus;1</sub>.
</td></tr>
<tr><td align="right" valign="top">
<i>N</i><sub>M</sub>
</td><td></td><td align="left" valign="top">
A total number of synapses to muscles, i.e.
<i>N</i><sub>M</sub> =
    <i>M</i><sub>0</sub>+&hellip;+<i>M</i><sub><i>U</i>&minus;1</sub>.
</td></tr>
<tr><td align="right" valign="top">
<i>X</i>
</td><td></td><td align="left" valign="top">
A number of columns along X axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>Y</i>
</td><td></td><td align="left" valign="top">
A number of columns along Y axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>C</i>
</td><td></td><td align="left" valign="top">
A number of territories along the columnar C axis of the tissue, i.e.
<i>C</i> = <i>N</i><sub>0</sub>+&hellip;+<i>N</i><sub><i>K</i>&minus;1</sub>.
</td></tr>
<tr><td align="right" valign="top">
<i>C</i><sub><i>S</i></sub>
</td><td></td><td align="left" valign="top">
It is the highest valid coordinate along the columnar axis C, i.e.
it is the number <i>C</i>+<i>N</i><sub><i>S</i></sub>&minus;1.
</td></tr>
<tr><td align="right" valign="top">
<i>M</i><sub>X</sub>
</td><td></td><td align="left" valign="top">
A mode map (either clip or torus) for X axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>M</i><sub>Y</sub>
</td><td></td><td align="left" valign="top">
A mode map (either clip or torus) for Y axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>M</i><sub>C</sub>
</td><td></td><td align="left" valign="top">
A mode map (either clip or torus) for the columnar axis C of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>RC</i><sub>X</sub>
</td><td></td><td align="left" valign="top">
Arrays of <i>K</i> radii for tissue cells in X axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>RC</i><sub>Y</sub>
</td><td></td><td align="left" valign="top">
Arrays of <i>K</i> radii for tissue cells in Y axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>RC</i><sub>C</sub>
</td><td></td><td align="left" valign="top">
Arrays of <i>K</i> radii for tissue cells in the columnar C axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>RS</i><sub>X</sub>
</td><td></td><td align="left" valign="top">
Arrays of <i>K</i> radii for signallings in X axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>RS</i><sub>Y</sub>
</td><td></td><td align="left" valign="top">
Arrays of <i>K</i> radii for signallings in Y axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>RS</i><sub>C</sub>
</td><td></td><td align="left" valign="top">
Arrays of <i>K</i> radii for signallings in the columnar C axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>RT</i><sub>X</sub>
</td><td></td><td align="left" valign="top">
Arrays of <i>K</i> radii for triples over territorial lists <i>LS</i>, <i>LT</i>,
and <i>LC</i> (see the lists
<a href="./cellab.html#territorial_lists">here</a>)
in X axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>RT</i><sub>Y</sub>
</td><td></td><td align="left" valign="top">
Arrays of <i>K</i> radii for triples over territorial lists <i>LS</i>, <i>LT</i>,
and <i>LC</i> (see the lists
<a href="./cellab.html#territorial_lists">here</a>)
in Y axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>RT</i><sub>C</sub>
</td><td></td><td align="left" valign="top">
Arrays of <i>K</i> radii for triples over territorial lists <i>LS</i>, <i>LT</i>,
and <i>LC</i> (see the lists
<a href="./cellab.html#territorial_lists">here</a>)
in the columnar C axis of the tissue.
</td></tr>
<tr><td align="right" valign="top">
<i>NB</i><sub>C</sub>
</td><td></td><td align="left" valign="top">
A number of bits reserved for a tissue cell. The number must be aligned to 8 bits
(i.e. a multiple of 8).
</td></tr>
<tr><td align="right" valign="top">
<i>NB</i><sub>S</sub>
</td><td></td><td align="left" valign="top">
A number of bits reserved for a synapse. The number must be aligned to 8 bits
(i.e. a multiple of 8).
</td></tr>
<tr><td align="right" valign="top">
<i>NB</i><sub>G</sub>
</td><td></td><td align="left" valign="top">
A number of bits reserved for a signalling. The number must be aligned to 8 bits
(i.e. a multiple of 8).
</td></tr>
</table>
<h3 id="dynamic_state">1.2&nbsp;&nbsp;&nbsp;Dynamic state</h3>
<p>
A dynamic state has the following general structure which is fully determined
by data stored in the corresponding static state.
</p>
<img class="figure"
     src="./tissue_logical_layout.svg"
     alt="[tissue_logical_layout.svg]">
<p>
We see three main components: a <em>tissue</em>, <em>sensory cells</em>,
and <em>synapses to muscles</em>. The tissue stores a major part of the neural tissue's
state. Sensory cells and synapses to muscles allow for information exchange between
the tissue and an external <i>environment</i> which is <i>not</i> a part of the model
(see the library
<a href="../envlab/envlab.html">envlab</a>
for more information).
</p>
<h4 id="tissue">1.2.1&nbsp;&nbsp;&nbsp;Tissue</h4>
<p>
It is a 2D array of <em>columns</em>.
There is <i>X</i> columns along the X axis and <i>Y</i> columns along the Y axis.
Valid indices to the array belong to the set
{0,&hellip;,<i>X</i>&minus;1}&times;{0,&hellip;,<i>Y</i>&minus;1}.
All columns in the tissue have the identical structure. Each column consists of
<i>C</i> <i>territories</i> aligned along the <i>columnar</i> axis C.
Each territory is uniquely identified in its column by a columnar
coordinate taken from the set {0,&hellip;,<i>C</i>&minus;1}. Moreover,
a territory  is uniquely identified in the whole tissue by three coordinates
along the axes X, Y, and C. Territories are thus regularly distributed in the
<em>left-handed</em> 3D Cartesian space
[<a href="./cellab.html#r02">2</a>].
We discuss the structure of a column and a territory in a
<a href="./cellab.html#structure_of_column">separate section</a>
later. For now
it is sufficient to say that the model allows to split territories in a column
into <i>K</i> different <i>kinds</i> {0,&hellip;,<i>K</i>&minus;1}. We can see
in the picture that first <i>N</i><sub>0</sub> territories in each column are
of the kind 0, next <i>N</i><sub>1</sub> territories are of the kind 1, and so on.
Observe that
<i>C</i> = <i>N</i><sub>0</sub> + &hellip; + <i>N</i><sub><i>K</i>&minus;1</sub>.
The neural tissue does <em>not</em> define interpretations of kinds.
This is left for parametrisations. For example, a parametrisation
may interpret a kind as an identifier of an algorithm simulating certain behavior
of a component inside a territory of that kind.
</p>
<h4 id="sensory_cells">1.2.2&nbsp;&nbsp;&nbsp;Sensory cells</h4>
<p>
Sensory cells store information coming form the external environment. We hold the
cells in a single array of the length <i>N</i><sub><i>S</i></sub>. The array is
depicted from the top down in the picture. We split sensory cell into <i>S</i>
different <i>sensory kinds</i> {0,&hellip;,<i>S</i>&minus;1}. We see in the picture
that first <i>N</i><sub><i>K</i></sub> sensory cells are of the sensory kind 0, next
<i>N</i><sub><i>K</i>+1</sub> sensory cells are of the sensory kind 1, and so on.
The neural tissue does <em>not</em> define interpretations of these sensory kinds.
This is left for parametrisations. For example, a parametrisation may interpret
a sensory kind as an assignment of sensory cells (of that kind) to particular
sense organs like eye, ear, nose, etc. The sense organs and also the process
of encoding of information captured by senses into the corresponding sensory
cells are <i>not</i> parts of the neural tissue. They belong to the
environment.
</p><p>
We align sensory cells with the columnar axis C of the tissue (the axis is depicted
on the left of the array). It means that each sensory cell has a unique
coordinate along the axis. We can see in the picture that the first sensory cell
(depicted at the top) is associated with the columnar coordinate <i>C</i> and
the last sensory cell has the coordinate <i>C</i><sub><i>S</i></sub>. Clearly,
<i>C</i><sub><i>S</i></sub>
    = <i>C</i> + <i>N</i><sub><i>S</i></sub> &minus; 1
    = <i>N</i><sub>0</sub> + &hellip; + <i>N</i><sub><i>K</i>+<i>S</i>&minus;1</sub> &minus; 1.
Note though that sensory cells do <em>not</em> have coordinates along X and Y axes
of the tissue.
</p>
<h4 id="synapses_to_muscles">1.2.3&nbsp;&nbsp;&nbsp;Synapses to muscles</h4>
<p>
Synapses to muscles store information computed for the external environment.
We hold synapses to muscles in two arrays of the same length
<i>N</i><sub><i>M</i></sub>. A synapse to muscle is a pair of elements
appearing at the same index in both arrays. We can see in the picture how
elements of both arrays are aligned. Both arrays are depicted from the top
down. The information for the external environment is stored only in elements
of the list on the left. Elements of the list on the right hold tissue coordinates
of territories from which the information for the environment
is actually computed. Each synapse to muscle is linked to exactly one
territory in the tissue. We split synapses to muscles into <i>U</i> different
<i>muscle kinds</i> {0,&hellip;,<i>U</i>&minus;1}.  We see in the picture
that first <i>M</i><sub>0</sub> synapses to muscles are of the muscle kind 0,
next <i>M</i><sub>1</sub> synapses to muscles are of the muscle kind 1, and so on.
Clearly, <i>N</i><sub><i>M</i></sub> =
    <i>M</i><sub>0</sub> + &hellip; + <i>M</i><sub><i>U</i>&minus;1</sub>.
The neural tissue does <em>not</em> define interpretations
of muscle kinds. This is left for parametrisations. For example,
a parametrisation may interpret a kind as an assignment of synapses (of that kind)
to a particular muscle like biceps, triceps, etc. Muscles, a process of decoding
information stored in synapses, and an update of the environment
according to the decoded information are <i>not</i> parts of the neural tissue.
They all belong to the environment.
</p>
<h4 id="structure_of_column">1.2.4&nbsp;&nbsp;&nbsp;Structure of column in tissue</h4>
<p>
We already know that a tissue column is a list of territories aligned along the
columnar axis and that territories are logically grouped according to kinds.
In this section we considerably extend this description. We start with a picture
where we show a column and its territories with all their components.
</p>
<img class="figure"
     src="./column_and_cell_territory_structure.svg"
     alt="[column_and_cell_territory_structure.svg]">
<p>
We see that all territories (across all kinds) consist of six types of
components: a tissue <em>cell</em>, <em>signalling</em>, <em>delimiters list</em>,
and three lists of <em>synapses</em>, <em>territorial states</em> of synapses, and
<em>coordinates of source cells</em> of synapses. These three lists have the same length
in each territory (of any kind). Moreover, lengths of the lists in all territories of
the kind 0 is <i>T</i><sub>0</sub>, lengths of the lists in all territories of the kind 1
is <i>T</i><sub>1</sub>, and so on.
</p><p>
Each territory in the neural tissue is a <em>behavioral model</em> of a corresponding
spatial region in a modelled mammalian cerebral cortex
[<a href="./cellab.html#r01">1</a>].
If the mammalian cerebral cortex consists of <i>n</i> neurons
[<a href="./cellab.html#r03">3</a>],
then we can always spatially partition the whole
matter of the cortex into <i>n</i> non-overlapping regions with bodies of the neurons
in their centers. Besides the body of a neuron a region typically also contains synapses
[<a href="./cellab.html#r04">4</a>]
connected to the neuron, axons
[<a href="./cellab.html#r05">5</a>]
and dendrites
[<a href="./cellab.html#r06">6</a>]
traversing the region, glia cells
[<a href="./cellab.html#r07">7</a>],
inter-cellular liquid, and so on.
A territory, as a model of a region, is thus supposed to model all desired behaviour
occurring in the region.
</p><p>
A territory is, in fact, an abstract term in the neural tissue. Indeed, it is
associated with no data. It is only a term allowing us to collectively name
components mentioned above with physical data. The components together are thus
supposed to model the corresponding region. We describe them in subsections below.
</p>
<h5 id="tissue_cell">Tissue cell</h5>
<p>
It is an array of <i>NB</i><sub><i>C</i></sub> bits storing a compressed
state of a modelled neuron (whose body lies in the center of a region
in the mammalian cerebral cortex associated with the territory).
We do <em>not</em> define interpretation of individual bits
(i.e. what information is stored) nor a compression method. This is left for
parametrisations. For example, a parametrisation may choose (according to the
kind of the territory) to store a state of the leaky integrate-and-fire neuron
[<a href="./cellab.html#r09">9</a>,
 <a href="./cellab.html#r08">8</a>],
the Izhikevich neuron
[<a href="./cellab.html#r10">10</a>,
 <a href="./cellab.html#r08">8</a>],
the McCulloch-Pitts neuron
[<a href="./cellab.html#r11">11</a>,
 <a href="./cellab.html#r08">8</a>],
Hodgkin-Huxley neuron
[<a href="./cellab.html#r12">12</a>,
 <a href="./cellab.html#r08">8</a>],
or any other available model of a neuron. A compression method can be, for example,
serialisation
[<a href="./cellab.html#r13">13</a>].
</p><p>
We define a term <em>a kind of tissue cell</em> as a synonym for <em>a kind of a
territory</em>. Although the later is more accurate from the theoretical point of
view, in the C++ implementation of the library it is more convenient to use the
former term due to the abstract nature of a territory (it has no data) and since a
tissue cell is the central component from the point of view of the computational
complexity.
</p>
<h5 id="territorial_lists">Territorial lists</h5>
<p>
There are four lists in a territory. Namely, the list of <em>synapses</em>, the list
of <em>territorial states</em>, the list of <em>coordinates of source cells</em>,
and the <em>delimiters list</em>. The first three lists are tightly related.
Namely their elements on the same indices form triples; each triple models an
axon
[<a href="./cellab.html#r05">5</a>]
terminated in or traversing the territory. The delimiters list is an increasing
sequence of exactly six indices into the other three lists simultaneously.
The relations between all lists are depicted in the picture below for a territory
of a kind <i>i</i> (the cell and the signalling are omitted).
</p>
<img class="figure"
     src="./territorial_lists.svg"
     alt="[territorial_lists.svg]">
<p>
The delimiters list <i>D</i> is depicted on the left and the three other
lists are depicted on the right, from the top down. The symbols <i>LS</i>,
<i>LT</i>, and <i>LC</i> denote the lists of synapses,
territorial states, and coordinates of source cells, respectively. Observe that these three
lists have the same length and elements on the same indices are aligned, i.e. they form
triples across the lists.
</p><p>
For each an index <i>j</i> (0&le;<i>j</i>&lt;<i>T</i><sub><i>i</i></sub>) a triple
(<i>LS</i>[<i>j</i>],
<i>LT</i>[<i>j</i>],
<i>LC</i>[<i>j</i>])
represents a model of an axon
[<a href="./cellab.html#r05">5</a>]
projected from a certain tissue cell to this territory. It is assumed in the neural
tissue that the triple models the whole axon, including all its important parts like
the growth cone
[<a href="./cellab.html#r21">21</a>]
(when the axon is searching for a target tissue cell),
the synapse
[<a href="./cellab.html#r04">4</a>]
(when the axon is connected to a tissue cell),
and the (myelinated
[<a href="./cellab.html#r22">22</a>])
fibre itself. Nevertheless, we do <em>not</em> specify
in what details what parts of an axon are modelled. It is left for a parametrisation.
Therefore, a parametrisation may, in fact, abstract any part of an axon in a way
that it actually has no representation in the triple.
    <!--We discuss properties of-->
<!--all element of the triple in the following three subsections.-->
</p><p>
Now we focus on individual components of
(<i>LS</i>[<i>j</i>],
<i>LT</i>[<i>j</i>],
<i>LC</i>[<i>j</i>]).
The third component <i>LC</i>[<i>j</i>] stores tissue coordinates
<i>x</i>, <i>y</i>, and <i>c</i> of either tissue or sensory cell from which
the modelled axon is projected. We call that cell as <em>source cell</em>.
If <i>c</i> &lt; <i>C</i>, then the source cell is a tissue cell. Otherwise,
it is a sensory cell. A single tissue or sensory cell may be referenced
by arbitrary many triples in lists <i>LC</i> of any territories.
A parametrisation is responsible for setting coordinates in lists <i>LC</i>
of all territories in the neural tissue. The library
<a href="../cellconnect/cellconnect.html"><kbd>cellconnect</kbd></a>
provides algorithms for this task.
</p><p>
The second component <i>LT</i>[<i>j</i>] has one of seven
possible integer values 0,&hellip;,6. Their interpretations are given in the table
below. There we assume tissue coordinates of this territory are <i>x</i><sub>0</sub>,
<i>y</i><sub>0</sub>, and <i>c</i><sub>0</sub>.
</p>
<table class="enumerate">
<tr>
<th>Value&nbsp;&nbsp;&nbsp;</th>
<th>Interpretation</th>
</tr>
<tr>
<td align="center" valign="top">0</td>
<td>
The axon is connected to the cell of this territory via a synapse
[<a href="./cellab.html#r04">4</a>]. The cell can thus accept information
(typically as action potentials
[<a href="./cellab.html#r23">23</a>])
from the tissue cell inside the territory at coordinates
<i>LC</i>[<i>j</i>].
</td>
</tr>
<tr>
<td align="center" valign="top">1</td>
<td>
The axon is not connected. Its growth cone is passing through this territory
into a territory at coordinates
<i>x</i><sub>0</sub>+1, <i>y</i><sub>0</sub>, <i>c</i><sub>0</sub>.
</td>
</tr>
<tr>
<td align="center" valign="top">2</td>
<td>
The axon is not connected. Its growth cone is passing through this territory
into a territory at coordinates
<i>x</i><sub>0</sub>&minus;1, <i>y</i><sub>0</sub>, <i>c</i><sub>0</sub>.
</td>
</tr>
<tr>
<td align="center" valign="top">3</td>
<td>
The axon is not connected. Its growth cone is passing through this territory
into a territory at coordinates
<i>x</i><sub>0</sub>, <i>y</i><sub>0</sub>+1, <i>c</i><sub>0</sub>.
</td>
</tr>
<tr>
<td align="center" valign="top">4</td>
<td>
The axon is not connected. Its growth cone is passing through this territory
into a territory at coordinates
<i>x</i><sub>0</sub>, <i>y</i><sub>0</sub>&minus;1, <i>c</i><sub>0</sub>.
</td>
</tr>
<tr>
<td align="center" valign="top">5</td>
<td>
The axon is not connected. Its growth cone is passing through this territory
into a territory at coordinates
<i>x</i><sub>0</sub>, <i>y</i><sub>0</sub>, <i>c</i><sub>0</sub>+1.
</td>
</tr>
<tr>
<td align="center" valign="top">6</td>
<td>
The axon is not connected. Its growth cone is passing through this territory
into a territory at coordinates
<i>x</i><sub>0</sub>, <i>y</i><sub>0</sub>, <i>c</i><sub>0</sub>&minus;1.
</td>
</tr>
</table>
<p>
Algorithms of the neural tissue ensure that no axon escapes from the neural
tissue. The raw coordinates above are mapped to valid ranges along all three
coordinate axes (see the
<a href="./cellab.html#axis_mode">next subsection</a>
for details).
</p><p>
Finally, the first component <i>LS</i>[<i>j</i>] is an array of
<i>NB</i><sub><i>S</i></sub> bits where all remaining information about the
modelled axon is stored in an compressed form. We do <em>not</em> define
interpretation of individual bits (i.e. what information is stored) nor a
compression method. This is left for parametrisations.
</p><p>
Observe that <i>LS</i>[<i>j</i>] is called a synapse (since <i>LS</i> is the list
of synapses), although it may hold data representing any part (or even several
parts) of the modelled axon, like a growth cone, fibre, and so on.
There is thus a significant difference between a synapse defined here (an element
of <i>LS</i>) and a synapse
[<a href="./cellab.html#r04">4</a>]
representing a chemical or electrical connection between an axon and a neuron
in a mammalian cerebral cortex.
</p><p>
Delimiters list <i>D</i> has no interpretation in the modelled
mammalian cerebral cortex. It is a technicality boosting algorithms of the neural
tissue operating on the other three lists. Here we discuss only a necessary minimum
about the algorithms to understand the meaning of <i>D</i> (details are
<kbd style="color:red">HERE</kbd> and <kbd style="color:red">HERE</kbd>).
The lists <i>LS</i>, <i>LT</i>, and <i>LC</i> are synchronously sorted according
to information stored in <i>LT</i> (remember that elements of <i>LT</i>
are integers from the set {0,&hellip;,6}). By synchronous sorting we mean that if for
some indices <i>j</i> and <i>k</i> the elements <i>LT</i>[<i>j</i>]
and <i>LT</i>[<i>k</i>] are in the wrong order, then there is swapped
<i>LS</i>[<i>j</i>] with  <i>LS</i>[<i>k</i>],
<i>LT</i>[<i>j</i>] with  <i>LT</i>[<i>k</i>],
and
<i>LC</i>[<i>j</i>] with  <i>LC</i>[<i>k</i>].
In other words, the sorting respects the triples constructed across the lists.
Once the lists are sorted, we construct a look-up table
<i>D'</i></sub> =
[0, <i>n</i><sub>0</sub>, <i>n</i><sub>1</sub>, <i>n</i><sub>2</sub>,
    <i>n</i><sub>3</sub>, <i>n</i><sub>4</sub>, <i>n</i><sub>5</sub>,
    <i>T</i><sub><i>i</i></sub>],
where <i>n</i><sub><i>j</i></sub> is a number of elements in
<i>LT</i> less than or equal to <i>j</i>. For each
<i>k</i>&isin;{0,&hellip;,6} the look-up table identifies a range of indices
of triples, namely <i>D'</i>[<i>k</i>],&hellip;,<i>D'</i>[<i>k</i>+1]&minus;1,
which all have the same value <i>k</i> in the list <i>LT</i>. The delimiters list
<i>D</i><sub><i>i</i></sub> is then defined as
[<i>n</i><sub>0</sub>, <i>n</i><sub>1</sub>, <i>n</i><sub>2</sub>,
    <i>n</i><sub>3</sub>, <i>n</i><sub>4</sub>, <i>n</i><sub>5</sub>].
We store <i>D</i> in the territory instead of <i>D'</i> in order to save memory.
The reconstruction of <i>D'</i> from <i>D</i> is trivial. Note that we call
the numbers <i>n</i><sub><i>j</i></sub> as <em>delimiters</em>.
</p>
<h5 id="signalling">Signalling</h5>
<p>
It is an array of <i>NB</i><sub><i>G</i></sub> bits storing that part
of a state of a territory which is not modelled by any other component
of that territory. A compression is used to store the information.
We do <em>not</em> define interpretation of individual bits
(i.e. what information is stored) nor a compression method. This is left for
parametrisations. For example, a parametrisation may store an information
necessary for guidance of axons
[<a href="./cellab.html#r14">14</a>,
 <a href="./cellab.html#r15">15</a>,
 <a href="./cellab.html#r16">16</a>]
passing through the territory to reach target cells. The information may be
expressed, for example, in a form of a distribution of concentrations of
guidance cues
[<a href="./cellab.html#r17">17</a>,
 <a href="./cellab.html#r18">18</a>,
 <a href="./cellab.html#r19">19</a>,
 <a href="./cellab.html#r20">20</a>]
in the 3D space associated with the territory. A compression method can be,
for example, serialisation
[<a href="./cellab.html#r13">13</a>].
</p><p>

</p>
<h4 id="axis_mode">1.2.5&nbsp;&nbsp;&nbsp;Modes of tissue coordinate axes</h4>
<p>
Each of the three coordinate axes X, Y, and C of the tissue is used in
one of two possible modes: <em>clipping</em> or <em>torus</em>.
Once a mode is chosen for an axis, it is fixed and cannot be further changed.
A mode specifies a mapping from all possible coordinates (i.e. integers)
to the valid range of the axis. We use symbols <i>M</i><sub>X</sub>,
<i>M</i><sub>Y</sub>, and <i>M</i><sub>C</sub> to denote the mode maps of
the axes X, Y, and C respectively.
</p><p>
The clipping mode maps each negative coordinate to 0, each coordinate
in the valid range to itself, and each coordinate greater than the
greatest valid coordinate to the greatest valid coordinate.
</p><p>
The torus mode maps each coordinate to its residue class modulo <i>g</i>+1
[<a href="./cellab.html#r24">24</a>,<a
    href="./cellab.html#r25">25</a>],
where <i>g</i> is the greatest valid coordinate. Available residue
classes are those of the least residue system modulo <i>g</i>+1, i.e.
0,&hellip;,<i>g</i>. For example, <i>g</i>+1 is mapped to 0, &minus;1 to
<i>g</i>&minus;1, <i>g</i>+2 to 1, &minus;2 to
<i>g</i>&minus;2, and so on.
</p>
<h4 id="neighbourhood">1.2.6&nbsp;&nbsp;&nbsp;Neighbourhoods of components of territories</h4>
<p>
Let (<i>x</i>,<i>y</i>,<i>c</i>) be tissue coordinates and <i>r</i><sub><i>x</i></sub>,
<i>r</i><sub><i>y</i></sub>, and <i>r</i><sub><i>c</i></sub> be non-negative integers.
A <em>neighbourhood</em> at coordinates (<i>x</i>,<i>y</i>,<i>c</i>) with <em>radii</em>
<i>r</i><sub><i>x</i></sub>, <i>r</i><sub><i>y</i></sub>, <i>r</i><sub><i>c</i></sub>
is a set of all tissue coordinates
(<i>M</i><sub>X</sub>(<i>x</i>+&Delta;<i>x</i>),
<i>M</i><sub>Y</sub>(<i>y</i>+&Delta;<i>y</i>),
<i>M</i><sub>C</sub>(<i>c</i>+&Delta;<i>c</i>)), where
&minus;<i>r</i><sub><i>x</i></sub> &le; &Delta;<i>x</i> &le; <i>r</i><sub><i>x</i></sub>,
&minus;<i>r</i><sub><i>y</i></sub> &le; &Delta;<i>y</i> &le; <i>r</i><sub><i>y</i></sub>,
and
&minus;<i>r</i><sub><i>c</i></sub> &le; &Delta;<i>c</i> &le; <i>r</i><sub><i>c</i></sub>.
</p><p>
A parametrisation of the neural tissue has to specify radii, in all three axes X, Y,
and C, for certain components of territories. The radii are then used by algorithms of the
neural tissue to build neighbourhoods associated with those components. For each kind
of territory there is defined one set of radii. It means that components of territories
of the same kind share radii defined for that kind. Namely, a parametrisation has to
specify for each territory kind <i>i</i> radii <i>RC</i><sub>X</sub>[<i>i</i>],
<i>RC</i><sub>Y</sub>[<i>i</i>], and <i>RC</i><sub>C</sub>[<i>i</i>] for
tissue cells, radii <i>RS</i><sub>X</sub>[<i>i</i>], <i>RS</i><sub>Y</sub>[<i>i</i>],
and <i>RS</i><sub>C</sub>[<i>i</i>] for signallings, and radii
<i>RT</i><sub>X</sub>[<i>i</i>], <i>RT</i><sub>Y</sub>[<i>i</i>], and
<i>RT</i><sub>C</sub>[<i>i</i>] for all triples over territorial lists <i>LS</i>,
<i>LT</i>, and <i>LC</i>.
</p>
<h2 id="memory_representation">2.&nbsp;&nbsp;&nbsp;Representation of neural tissue in memory</h2>
<p>
Here we show how a state of the neural tissue (whose logical structure was presented
in the previous section) is physically stored in the memory. The chosen memory layout
is a compromise between these two incompatible properties:
</p>
<ul><li>
A ratio of bits in which a state of the neural tissue is encoded and all bits physically
allocated for the state is as close to 1 as possible.
</li><li>
Transition algorithms of the neural tissue (discussed in the next section) can
operate as efficiently as possible on the stored state.
</li></ul>
<h3 id="static_state_memory_rep">2.1&nbsp;&nbsp;&nbsp;Static state</h3>
<p>
It does not require any special treatment. Its memory footprint is typically negligible,
compared to the corresponding dynamic state. Indeed, its size is a function
(a linear combination) of the parameters <i>K</i>, <i>S</i>, and <i>U</i>,
i.e. counts of kinds of territories, sensory cell, and synapses to muscles,
respectively. Therefore, a static state is basically represented as a tuple
of read-only properties as they are listed in the
<a href="./cellab.html#static_state">section 1.1</a>.
Nevertheless, the following three deviations are worth mentioning:
</p>
<ul><li>
The mode maps <i>M</i><sub>X</sub>, <i>M</i><sub>Y</sub>, and <i>M</i><sub>C</sub>
are represented only as three boolean values instead
of the maps themselves: <i>true</i> identifies the torus map and <i>false</i>
the clip map. Transition algorithms then behave according to these boolean values,
i.e. they use the maps accordingly.
</li><li>
There is built a look-up table of <i>K</i>+<i>S</i> coordinates along the columnar
axis of the tissue. At an index <i>i</i> there is stored the number
<i>N</i><sub>0</sub>+&hellip;+<i>N</i><sub><i>i</i></sub>.
</li><li>
There is built a look-up table of <i>U</i> indices of synapses to muscles. At an index
<i>i</i> there is stored the number
<i>M</i><sub>0</sub>+&hellip;+<i>M</i><sub><i>i</i></sub>.
</li></ul>
<p>
A static state is implemented as <kbd>struct static_state_of_neural_tissue</kbd> in
source files
</p>
<ul><li>
<a href="../../../code/cellab/include/cellab/static_state_of_neural_tissue.hpp">
    <kbd>static_state_of_neural_tissue.hpp</kbd></a> and
</li><li>
<a href="../../../code/cellab/src/static_state_of_neural_tissue.cpp">
    <kbd>static_state_of_neural_tissue.cpp</kbd></a>.
</li></ul>
<h3 id="dynamic_state_memory_rep">2.2&nbsp;&nbsp;&nbsp;Dynamic state</h3>
<p>
It is stored in 6<i>K</i>+3 separately allocated memory blocks. The tissue is
stored in 6<i>K</i> memory blocks, called <em>slices</em>. The sensory cells
are store in one memory block, and synapses to muscles are stored in the
remaining two memory blocks. The whole memory layout is depicted in this picture.
</p>
<img class="figure"
     src="./tissue_physical_layout.svg"
     alt="[tissue_physical_layout.svg]">
<p>
The tissue is depicted in the top part of the picture. We see that components
of all territories are grouped according to their type: for each of 6 component
types (cell, signalling, delimiters list, synapse, territorial state, and coordinates
to source cell) we have an array of <i>K</i> slices (for each kind of territory one
slice). Each slice stores all those components of the same type which lie inside
territories of the same kind.
</p><p>
Slices are internally organised as 3D arrays. For each slice a number of bits per
its element is shown in the picture as a number (or an expression) in the front face
of the slice. There we use an "angle bracket" operator: for any non-negative
integer <i>n</i> the value &lt;<i>n</i>&gt; is the smallest integer multiple of 8
such that <i>n</i> &lt; 2<sup>&lt;<i>n</i>&gt;</sup>. In other words, &lt;<i>n</i>&gt;
is a count of bits in the 1-byte aligned value <i>n</i>. For example, &lt;6&gt; is 8,
because the value 6 can be stored in a single byte, which gives us 8 bits. Ranges
of all three indices into a slice are depicted for each slice in the picture. First
two indices to any slice are nothing but tissue coordinates along the axes X and Y.
An interpretation of the third index differs among types of components.
In the following table we show a direct correspondence between elements
of individual slices and tissue components as they were presented in the
<a href="./cellab.html#neural_tissue">previous section</a>. We assume in the
table that <i>i</i> is a kind of a territory (i.e. it is an index of a slice in
an array of slices) and <i>r</i>, <i>s</i>, <i>t</i> are three indices into the
referenced slice.
</p>
<table class="enumerate">
<tr>
<th align="right" valign="bottom">Element (<i>r</i>,<i>s</i>,<i>t</i>)
    in slice at index <i>i</i> of</th>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<th align="left" valign="bottom">Corresponding tissue component, where
    <i>p</i>=<i>N</i><sub>0</sub>+&hellip;+<i>N</i><sub><i>i</i>&minus;1</sub></th>
</tr>
<tr>
<td align="right" valign="top">cells</td><td>&nbsp;&nbsp;</td>
<td>
The tissue cell at tissue coordinates (<i>r</i>, <i>s</i>, <i>t</i>+<i>p</i>).
</td>
</tr>
<tr>
<td align="right" valign="top">signallings</td><td>&nbsp;&nbsp;</td>
<td>
The signalling at tissue coordinates (<i>r</i>, <i>s</i>, <i>t</i>+<i>p</i>).
</td>
</tr>
<tr>
<td align="right" valign="top">delimiters lists</td><td>&nbsp;&nbsp;</td>
<td>
The delimiters list at tissue coordinates (<i>r</i>, <i>s</i>, <i>t</i>+<i>p</i>).
</td>
</tr>
<tr>
<td align="right" valign="top">synapses</td><td>&nbsp;&nbsp;</td>
<td>
The synapse <i>LS</i>[<i>t</i> <i>mod</i> <i>T</i><sub><i>i</i></sub>]
inside the territory at tissue coordinates (<i>r</i>, <i>s</i>,
&lfloor;<i>t</i> / <i>T</i><sub><i>i</i></sub>&rfloor; + <i>p</i>).
</td>
</tr>
<tr>
<td align="right" valign="top">territorial states</td><td>&nbsp;&nbsp;</td>
<td>
The territorial state <i>LT</i>[<i>t</i> <i>mod</i> <i>T</i><sub><i>i</i></sub>]
inside the territory at tissue coordinates (<i>r</i>, <i>s</i>,
&lfloor;<i>t</i> / <i>T</i><sub><i>i</i></sub>&rfloor; + <i>p</i>).
</td>
</tr>
<tr>
<td align="right" valign="top">coordinates of source cells</td><td>&nbsp;&nbsp;</td>
<td>
The tissue coordinates of source cell <i>LC</i>[<i>t</i> <i>mod</i>
<i>T</i><sub><i>i</i></sub>] inside the territory at tissue coordinates (<i>r</i>, <i>s</i>,
&lfloor;<i>t</i> / <i>T</i><sub><i>i</i></sub>&rfloor; + <i>p</i>).
</td>
</tr>
</table>
<p>
The memory layout of the sensory cells is depicted in the bottom left part of
the picture above. The sensory cells are stored in an array. Each sensory cell
occupies <i>NB</i><sub>C</sub> bits in the array. We see that first
<i>N</i><sub><i>K</i></sub> sensory cells are of the kind 0, then follows
<i>N</i><sub><i>K</i>+1</sub> sensory cells are of the kind 1, and so on.
</p><p>
The memory layout of the synapses to muscles is depicted in the bottom right part of
the picture above. We see that they are stored in two arrays with exactly the same
structure. The synapses themselves are stored in the left array, where
each synapse occupies <i>NB</i><sub>S</sub> bits. The right array stores coordinates
of sources tissue cells of the corresponding synapses (in the left array at the same
indices). Each triple of coordinates occupies
3&lt;<i>max</i>(<i>X</i>,<i>Y</i>,<i>C</i><sub><i>S</i></sub>)&gt;
bits in the array. We further see that first
<i>M</i><sub>0</sub> elements in both arrays correspond to synapses to muscles of the kind 0,
then follows <i>M</i><sub>1</sub> elements corresponding to synapses to muscles of the kind 1,
and so on.
</p><p>
A dynamic state is implemented as <kbd>struct dynamic_state_of_neural_tissue</kbd> in
source files
</p>
<ul><li>
<a href="../../../code/cellab/include/cellab/dynamic_state_of_neural_tissue.hpp">
    <kbd>dynamic_state_of_neural_tissue.hpp</kbd></a> and
</li><li>
<a href="../../../code/cellab/src/dynamic_state_of_neural_tissue.cpp">
    <kbd>dynamic_state_of_neural_tissue.cpp</kbd></a>.
</li></ul>
<h2 id="transition_algorithms">3.&nbsp;&nbsp;&nbsp;Transition algorithms</h2>
<p>
A computation of a next state of the neural tissue from the current one
(the structure of a state is described in
<a href="./cellab.html#neural_tissue">section 1</a>)
proceeds in six steps. The first step applies some modifications to the current
state of the neural tissue and each subsequent step adds other modifications
to a state received from the preceding step. Once the sixth step is done
the received state represents the next state of the neural tissue. Those
five intermediate states (between individual steps) do not represent valid
states of the neural tissue. It is absolutely necessary to apply the steps
sequentially in an exact order (which we specify later). Otherwise the result is undefined.
Each of the six steps applies its modifications into the same allocated memory.
It means, that the memory is allocated only once for an initial state of the
neural tissue (with which the simulation begins) and then all computation steps
(during whole simulation) only modify a content of that memory. Despite of that
all six steps together implement a function (in the exact mathematical sense) from
a valid state to another valid state of the neural tissue. We discuss individual
transition steps in the following six subsections in the order as they have to be
applied to a state of the neural tissue.
</p>
<h3 id="algorithm_synapses_to_muscles">3.1&nbsp;&nbsp;&nbsp;Transition of synapses to muscles</h3>
<p>
This algorithm, denoted as <i>A</i><sub>SM</sub>, represents the first of six steps
in the computation of a next state of the neural tissue from the current one.
The algorithm accepts an external function <i>F</i><sub>SM</sub> and a number of threads
<i>k</i> which can be used for the computation. The function <i>F</i><sub>SM</sub> is
a part of the parametrisation of the neural tissue, i.e. it is an external user-defined
function. It is called for individual synapses to muscles to compute their next states.
</p><p>
The computation starts in the function <kbd>apply_transition_of_synapses_to_muscles</kbd>.
There the algorithm first creates (from the current thread) <i>k</i>&minus;1 new threads
and then execution of all <i>k</i> threads proceeds to the function
<kbd>thread_apply_transition_of_synapses_to_muscles</kbd>. There each thread processes
a different sub-set of all synapses to muscles. The enumeration of right sub-set of
synapses in each thread is provided by the utility function
<kbd>go_to_next_index</kbd>, see
<a href="./cellab.html#parallel_enumeration">section 3.7</a>
for details. Each thread calls for each enumerated synapse to muscle the function
<i>F</i><sub>SM</sub> with the following information:
</p>
<table class="enumerate">
<tr>
<th align="right" valign="bottom">Name</th>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<th align="left" valign="bottom">Description</th>
</tr>
<tr>
<td align="right" valign="top"><kbd>bits_of_synapse</kbd></td><td>&nbsp;&nbsp;</td>
<td>
A reference to the memory, where is stored a packed information about the current
state of the updated synapse to muscle. It is the first element of the pair forming
complete data of the synapse to muscle in the neural tissue, see
<a href="./cellab.html#synapses_to_muscles">section 1.2.3</a>.
Note that it is the parametrisation who defines size, content, and a compression method
of the memory reserved for any synapse to a muscle. We thus assume that <i>F</i><sub>SM</sub>
already has (or is build on) that information.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>kind_of_synapse</kbd></td><td>&nbsp;&nbsp;</td>
<td >
The kind is computed directly from the index of an enumerated synapse using the
look-up table held in the static state of the neural tissue, see
<a href="./cellab.html#static_state_memory_rep">section 2.1</a>. <i>F</i><sub>SM</sub>
may use this kind, for example, to recognise right interpretation of data encoded
in <kbd>bits_of_synapse</kbd>, or to choose right procedure for computation of the
next state of the enumerated synapse to muscle.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>kind_of_src_cell</kbd></td><td>&nbsp;&nbsp;</td>
<td>
The kind of tissue cell located in the territory of the neural tissue identified by tissue
coordinates stored in an enumerated synapse to muscle. The coordinates represent the second
element of the pair forming complete data of the synapse to muscle in the neural tissue, see
<a href="./cellab.html#synapses_to_muscles">section 1.2.3</a>.
The kind of the cell is computed directly from the tissue coordinates using the
look-up table held in the static state of the neural tissue, see
<a href="./cellab.html#static_state_memory_rep">section 2.1</a>.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>bits_of_src_cell</kbd></td><td>&nbsp;&nbsp;</td>
<td>
A reference to the memory where is stored a tissue cell of the territory identified by tissue
coordinates stored in the enumerated synapse to muscle. The coordinates represent the second
element of the pair forming complete data of the synapse to muscle in the neural tissue, see
<a href="./cellab.html#synapses_to_muscles">section 1.2.3</a>.
Note that it is the parametrisation who defines size, content, and a compression method
of the memory reserved for any tissue cell. We thus assume that <i>F</i><sub>SM</sub>
already has (or is build on) that information. The passed source cell serves as a source
of information for computation of the next state of the updated synapse to muscle.
</td>
</tr>
</table>
<p>
Although the function <i>F</i><sub>SM</sub> is a part of a parametrisation of the
neural tissue (i.e. a user may implement it arbitrarily), there is a general
scheme of what steps the function should perform:
</p>
<ol>
<li>
Unpack and parse data referenced by <kbd>bits_of_synapse</kbd>. This is often
implemented as construction of an instance of an user-defined type representing a
synapse to muscle (the reference <kbd>bits_of_synapse</kbd> (and possibly other
data) is passed to the constructor).
</li>
<li>
Unpack and parse data referenced by <kbd>bits_of_src_cell</kbd>. This is often
implemented as construction of an instance of an user-defined type representing a
tissue cell (the reference <kbd>bits_of_src_cell</kbd> (and possibly other
data) is passed to the constructor).
</li>
<li>
Invoke a procedure on the unpacked synapse to muscle transforming
its current state to the next one. The unpacked tissue cell is typically also
needed in this computation.
</li>
<li>
Pack and write the updated state of the synapse to muscle to the memory
referenced by <kbd>bits_of_synapse</kbd> (i.e. overwrite the old content).
</li>
</ol>
<p>
We always assume <i>F</i><sub>SM</sub> is a single-threaded, thread-safe, and in-place
<a href="./cellab.html#r28">[28]</a>
procedure.
</p><p>
The algorithm is implemented in source files:
</p>
<ul><li>
<a href="../../../code/cellab/include/cellab/transition_algorithms.hpp">
    <kbd>transition_algorithms.hpp</kbd></a> and
</li><li>
<a href="../../../code/cellab/src/transition_of_synapses_to_muscles.cpp">
    <kbd>transition_of_synapses_to_muscles.cpp</kbd></a>
</li></ul>
<p>
We express the time complexity <i>T</i>(<i>A</i><sub>SM</sub>) of this algorithm in terms
of the number of synapses to muscles <i>N</i><sub>M</sub>, a time complexity
<i>T</i>(<i>F</i><sub>SM</sub>) of the function <i>F</i><sub>SM</sub>, a time constant
<i>T</i><sub>SM</sub> reflecting a management inside <i>A</i><sub>SM</sub> per each synapse
to muscle, and the number of threads <i>N</i><sub>T</sub> as
</p><p style="text-align:center">
<i>T</i>(<i>A</i><sub>SM</sub>) = (<i>T</i>(<i>F</i><sub>SM</sub>) + <i>T</i><sub>SM</sub>)
    &middot; <i>N</i><sub>M</sub> / <i>N</i><sub>T</sub>.
</p><p>
And we express the space complexity <i>S</i>(<i>A</i><sub>SM</sub>) of this algorithm in
terms of the number of bytes <i>S</i><sub>T</sub> allocated for a thread by the operating system,
a space complexity <i>S</i>(<i>F</i><sub>SM</sub>) of the function <i>F</i><sub>SM</sub>,
a constant space <i>S</i><sub>SM</sub> reflecting a management inside <i>A</i><sub>SM</sub>
per each synapse to muscle, and the number of threads <i>N</i><sub>T</sub> as
</p><p style="text-align:center">
<i>S</i>(<i>A</i><sub>SM</sub>) = (<i>S</i>(<i>F</i><sub>SM</sub>) + <i>S</i><sub>T</sub> +
    <i>S</i><sub>SM</sub>)
    &middot; <i>N</i><sub>T</sub>.
</p>
<h3 id="algorithm_synapses_in_tissue">3.2&nbsp;&nbsp;&nbsp;Transition of synapses in tissue</h3>
<p>
This algorithm, denoted as <i>A</i><sub>TS</sub>, represents the second of six steps in the
computation of a next state of the neural tissue from the current one.
The algorithm accepts an external function <i>F</i><sub>TS</sub> and a number of threads
<i>k</i> which can be used for the computation. The function <i>F</i><sub>TS</sub> is
a part of the parametrisation of the neural tissue, i.e. it is an external user-defined
function. It is called for individual synapses in the tissue to compute their next states.
</p><p>
The computation starts in the function <kbd>apply_transition_of_synapses_of_tissue</kbd>.
There the algorithm first creates (from the current thread) <i>k</i>&minus;1 new threads
and then execution of all <i>k</i> threads proceeds to the function
<kbd>thread_apply_transition_of_synapses_of_tissue</kbd>. There each thread processes
a different sub-set of all synapses in the tissue. The enumeration of right sub-set of
synapses in each thread is provided by the utility function
<kbd>go_to_next_coordinates</kbd>, see
<a href="./cellab.html#parallel_enumeration">section 3.7</a>
for details. Each thread calls for each enumerated synapse the function
<i>F</i><sub>TS</sub> with the following information:
</p>
<table class="enumerate">
<tr>
<th align="right" valign="bottom">Name</th>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<th align="left" valign="bottom">Description</th>
</tr>
<tr>
<td align="right" valign="top"><kbd>bits_of_synapse</kbd></td><td>&nbsp;&nbsp;</td>
<td>
A reference to the memory, where is stored a packed information about the current
state of the updated synapse in the tissue. It is the first element of the triple over
aligned elements in the lists <i>LS</i>, <i>LT</i>, and <i>LC</i>, see paragraph
<a href="./cellab.html#territorial_lists">Territorial lists</a>
in the
<a href="./cellab.html#structure_of_column">section 1.2.4</a>.
Note that it is the parametrisation who defines size, content, and a compression method
of the memory reserved for any synapse in the tissue. We thus assume that
<i>F</i><sub>TS</sub> already has (or is build on) that information.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>kind_of_src_cell</kbd></td><td>&nbsp;&nbsp;</td>
<td>
The kind of a tissue cell located in the territory of the neural tissue identified by tissue
coordinates stored in an enumerated synapse to muscle. The coordinates represent the third
element of the triple over aligned elements in the lists <i>LS</i>, <i>LT</i>, and <i>LC</i>,
see paragraph
<a href="./cellab.html#territorial_lists">Territorial lists</a>
in the
<a href="./cellab.html#structure_of_column">section 1.2.4</a>.
The kind of the cell is computed directly from the tissue coordinates using the
look-up table held in the static state of the neural tissue, see
<a href="./cellab.html#static_state_memory_rep">section 2.1</a>.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>bits_of_src_cell</kbd></td><td>&nbsp;&nbsp;</td>
<td>
A reference to the memory where is stored a tissue cell of the territory identified
by tissue coordinates held in updated synapse (namely, in the third element of the
triple over aligned elements in the lists <i>LS</i>, <i>LT</i>, and <i>LC</i>, see paragraph
<a href="./cellab.html#territorial_lists">Territorial lists</a>
in
<a href="./cellab.html#structure_of_column">section 1.2.4</a>).
Note that it is the parametrisation who defines size, content, and a compression method
of the memory reserved for any tissue cell. We thus assume that <i>F</i><sub>TS</sub>
already has (or is build on) that information. The passed source cell serves as a source
of information for computation of the next state of the updated synapse in the tissue.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>kind_of_tgt_cell</kbd></td><td>&nbsp;&nbsp;</td>
<td>
The kind of a tissue cell located in the same territory of the neural tissue where
the updated synapse also appears. The kind of this cell is computed directly from the
known columnar coordinate of the territory.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>bits_of_tgt_cell</kbd></td><td>&nbsp;&nbsp;</td>
<td>
A reference to the memory where is stored a tissue cell of the same territory of the
neural tissue where the updated synapse also appears.
Note that it is the parametrisation who defines size, content, and a compression method
of the memory reserved for any tissue cell. We thus assume that <i>F</i><sub>TS</sub>
already has (or is build on) that information. The passed target cell serves as a source
of information for computation of the next state of the updated synapse in the tissue.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>territorial_state</kbd></td><td>&nbsp;&nbsp;</td>
<td>
This numeric constant specifies the current behaviour of the synapse in the territory.
There are only 7 possible values (territorial states) 0,&hellip;,6 for any synapse. The
value 0 means that the synapse is connected to the target cell appearing in the same
territory as the synapse, and the remaining 6 values say that the synapse only passes
through this territory to another territory in the neighbourhood. The synapse can move along
one of three coordinate axes (x, y, or columnar) in either positive or negative direction,
which gives us 6 possible moves.
See the header file
<a href="../../../code/cellab/include/cellab/territorial_state_of_synapse.hpp">
    <kbd>territorial_state_of_synapse.hpp</kbd></a>
for more info.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>shift_to_low_corner</kbd></td><td>&nbsp;&nbsp;</td>
<td>
This is a 3D vector pointing from the tissue coordinates of the current territory (i.e.
the territory where the synapse currently appears) to a territory with lowest possible
tissue coordinates which can be accessed from the user's callback function by calling
the function <kbd>get_signalling</kbd> discussed below.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>shift_to_high_corner</kbd></td><td>&nbsp;&nbsp;</td>
<td>
This is a 3D vector pointing from the tissue coordinates of the current territory (i.e.
the territory where the synapse currently appears) to a territory with highest possible
tissue coordinates which can be accessed from the user's callback function by calling
the function <kbd>get_signalling</kbd> discussed below.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>get_signalling</kbd></td><td>&nbsp;&nbsp;</td>
<td>
It is a function accepting a 3D vector pointing from the current territory
(i.e. the territory where the synapse currently appears) to any territory
within a region (box) given by the corner vectors <kbd>shift_to_low_corner</kbd>,
<kbd>shift_to_high_corner</kbd> discussed above. Said it differently, each coordinate
of any shift vector passed to this function must be within the range of coordinates
given by the corresponding coordinates of both mentioned corner vectors. And note
the shift vector is always a shift from the current territory. The function returns
a pair whose the first element is a reference to the memory where is stored
the signalling (see the paragraph
<a href="./cellab.html#signalling">Signalling</a>
in the
<a href="./cellab.html#structure_of_column">section 1.2.4</a>)
of the territory referenced by the passed vector, and the second argument is
the kind of that territory.
Note that it is the parametrisation who defines size, content, and a compression method
of the memory reserved for any sigannling. We thus assume that <i>F</i><sub>TS</sub>
already has (or is build on) that information.
</td>
</tr>
</table>
<p>
Although the function <i>F</i><sub>TS</sub> is a part of a parametrisation of the
neural tissue (i.e. a user may implement it arbitrarily), there is a general
scheme of what steps the function should perform:
</p>
<ol>
<li>
Unpack and parse data referenced by <kbd>bits_of_src_cell</kbd>,
<kbd>bits_of_src_cell</kbd>, and <kbd>bits_of_tgt_cell</kbd>. This is often
implemented as construction of instances of user-defined types (namely, one for
a tissue synapse and one for a tissue cell). The memory
references are passed to constructors of these data types.
</li><li>
Invoke a procedure on the unpacked synapse transforming
its current state to the next one. Both unpacked tissue cells are typically also
needed in this computation. The procedure is further required to compute a new
territorial state of the synapse. Since signallings in the neighbourhood may
be necessary in this computation, the procedure may use the function
<kbd>get_signalling</kbd> to receive access to their memory. Note that the procedure
typically unpacks and parses this memory in a similar way as we explained for the memories
of the synapse and the source and the target cell.
</li><li>
Pack and write the updated state of the tissue synapse to the memory
referenced by <kbd>bits_of_synapse</kbd> (i.e. overwrite the old content).
</li><li>
Return the new territorial state of the synapse, i.e. a number from the range
0,&hellip;,6.
</li>
</ol>
<p>
We always assume <i>F</i><sub>TS</sub> is a single-threaded, thread-safe, and in-place
<a href="./cellab.html#r28">[28]</a>
procedure.
</p><p>
The algorithm is implemented in source files:
</p>
<ul><li>
<a href="../../../code/cellab/include/cellab/transition_algorithms.hpp">
    <kbd>transition_algorithms.hpp</kbd></a> and
</li><li>
<a href="../../../code/cellab/src/transition_of_synapses_of_tissue.cpp">
    <kbd>transition_of_synapses_of_tissue.cpp</kbd></a>
</li></ul>
<p>
<!--We express the time complexity <i>T</i>(<i>A</i><sub>TS</sub>) of this algorithm in terms-->
<!--of the number of synapses inside the tissue <i>N</i><sub>M</sub>, a time complexity-->
<!--<i>T</i>(<i>F</i><sub>TS</sub>) of the function <i>F</i><sub>TS</sub>, a time constant-->
<!--<i>T</i><sub>TS</sub> reflecting a management inside <i>A</i><sub>TS</sub> per each synapse,-->
<!--and the number of threads <i>N</i><sub>T</sub> as-->
<i>N</i><sub>TS</sub> = <i>X</i>&middot;<i>Y</i>&middot;(<i>N</i><sub>0</sub><i>T</i><sub>0</sub>
    + &hellip; + <i>N</i><sub><i>K</i>&minus;1</sub><i>T</i><sub><i>K</i>&minus;1</sub>).
</p>
<p style="text-align:center">
<i>T</i>(<i>A</i><sub>TS</sub>) = (<i>T</i>(<i>F</i><sub>TS</sub>) + <i>T</i><sub>TS</sub> +
    <i>R</i><sup>3</sup>&middot;<i>T</i>(<kbd>get_signalling</kbd>))
    &middot; <i>N</i><sub>TS</sub> / <i>N</i><sub>T</sub>.
</p>
<!--<p>-->
<!--And we express the space complexity <i>S</i>(<i>A</i><sub>SM</sub>) of this algorithm in-->
<!--terms of the number of bytes <i>S</i><sub>T</sub> allocated for a thread by the operating system,-->
<!--a space complexity <i>S</i>(<i>F</i><sub>SM</sub>) of the function <i>F</i><sub>SM</sub>,-->
<!--a constant space <i>S</i><sub>SM</sub> reflecting a management inside <i>A</i><sub>SM</sub>-->
<!--per each synapse to muscle, and the number of threads <i>N</i><sub>T</sub> as-->
<!--</p>-->
<p style="text-align:center">
<i>S</i>(<i>A</i><sub>TS</sub>) = (<i>S</i>(<i>F</i><sub>TS</sub>) + <i>S</i><sub>T</sub> +
    <i>S</i><sub>TS</sub>)
    &middot; <i>N</i><sub>T</sub>.
</p>
<h3 id="algorithm_territorial_lists_of_synapses">3.3&nbsp;&nbsp;&nbsp;Transition of territorial lists of synapses</h3>
<p>
<kbd>go_to_next_coordinates</kbd>
</p>
<h3 id="algorithm_synaptic_migration_in_tissue">3.4&nbsp;&nbsp;&nbsp;Transition of synaptic migration in tissue</h3>
<p>
<kbd>go_to_next_coordinates</kbd>
</p>
<h3 id="algorithm_signalling">3.5&nbsp;&nbsp;&nbsp;Transition of signalling</h3>
<p>
<kbd>go_to_next_coordinates</kbd>
</p>
<h3 id="algorithm_cells_in_tissue">3.6&nbsp;&nbsp;&nbsp;Transition of cells in tissue</h3>
<p>
This algorithm represents the last of six steps in the computation of a next state of the
neural tissue from the current one.
The algorithm accepts an external function <i>F</i><sub>TC</sub> and a number of threads
<i>k</i> which can be used for the computation. The function <i>F</i><sub>TC</sub> is
a part of the parametrisation of the neural tissue, i.e. it is an external user-defined
function. It is called for individual cells in the tissue to compute their next states.
</p><p>
The computation starts in the function <kbd>apply_transition_of_cells_of_tissue</kbd>.
There the algorithm first creates (from the current thread) <i>k</i>&minus;1 new threads
and then execution of all <i>k</i> threads proceeds to the function
<kbd>thread_apply_transition_of_cells_of_tissue</kbd>. There each thread processes
a different sub-set of all cells in the tissue. The enumeration of right sub-set of
cells in each thread is provided by the utility function
<kbd>go_to_next_coordinates</kbd>, see
<a href="./cellab.html#parallel_enumeration">section 3.7</a>
for details. Each thread calls for each enumerated cell the function
<i>F</i><sub>TC</sub> with the following information:
</p>
<table class="enumerate">
<tr>
<th align="right" valign="bottom">Name</th>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<th align="left" valign="bottom">Description</th>
</tr>
<tr>
<td align="right" valign="top"><kbd>bits_of_cell</kbd></td><td>&nbsp;&nbsp;</td>
<td>
A reference to the memory, where is stored a packed information about the current
state of the updated cell in the tissue. It is the parametrisation who defines size,
content, and a compression method of the memory reserved for any cell in the tissue.
We thus assume that <i>F</i><sub>TC</sub> already has (or is build on) that information.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>kind_of_cell</kbd></td><td>&nbsp;&nbsp;</td>
<td>
The kind of the tissue cell whose memory is referenced by <kbd>bits_of_cell</kbd>.
This information can be used, for example, for selection of a particular sub-routine,
which will actually compute the next state of the updated cell.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>num_connected_synapses</kbd></td><td>&nbsp;&nbsp;</td>
<td>
It is a number of all those synapses in the territory of the updated cell, whose
territorial states (i.e. values in the list <i>LT</i>) are 0 (see paragraph
<a href="./cellab.html#territorial_lists">Territorial lists</a>
in
<a href="./cellab.html#structure_of_column">section 1.2.4</a>
and also
<a href="../../../code/cellab/include/cellab/territorial_state_of_synapse.hpp">
    <kbd>territorial_state_of_synapse.hpp</kbd></a>).
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>get_connected_synapse</kbd></td><td>&nbsp;&nbsp;</td>
<td>
It is a function allowing <i>F</i><sub>TC</sub> to enumerate all synapses connected
to the updated cell. This function accepts an index within the range
0,&hellip;,<kbd>num_connected_synapses</kbd>&minus;1 and returns a reference to the
memory where the indexed synapse is stored, the kind of source cell of the indexed synapse,
and the kind of the target cell of that synapse. Since the synapse is connected to the
updated cell, the kind of the target cell is always equal to <kbd>kind_of_cell</kbd>.
Note that the size, and content of synapse's memory is defined by the user.
We thus assume that user's function already has that information. The
function which is passed through this parameter to <i>F</i><sub>TC</sub> is
the function <kbd>get_synapse_callback_function</kbd> declared in the header file
<a href="../../../code/cellab/include/cellab/utilities_for_transition_algorithms.hpp">
    <kbd>utilities_for_transition_algorithms.hpp</kbd></a>.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>shift_to_low_corner</kbd></td><td>&nbsp;&nbsp;</td>
<td>
This is a 3D vector pointing from the tissue coordinates of the current territory (i.e.
the territory where the cell appears) to a territory with lowest possible
tissue coordinates which can be accessed from the user's callback function by calling
the function <kbd>get_signalling</kbd> discussed below.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>shift_to_high_corner</kbd></td><td>&nbsp;&nbsp;</td>
<td>
This is a 3D vector pointing from the tissue coordinates of the current territory (i.e.
the territory where the cell appears) to a territory with highest possible
tissue coordinates which can be accessed from the user's callback function by calling
the function <kbd>get_signalling</kbd> discussed below.
</td>
</tr>
<tr>
<td align="right" valign="top"><kbd>get_signalling</kbd></td><td>&nbsp;&nbsp;</td>
<td>
It is a function accepting a 3D vector pointing from the current territory
(i.e. the territory where the cell appears) to any territory
within a box given by corner vectors <kbd>shift_to_low_corner</kbd>, and
<kbd>shift_to_high_corner</kbd> discussed above. Said it differently, each coordinate
of any shift vector passed to this function must be within the range of coordinates
given by the corresponding coordinates of both mentioned corner vectors. And note
the shift vector is always a shift from the current territory. The function returns
a pair whose the first element is a reference to the memory where is stored
the signalling (see the paragraph
<a href="./cellab.html#signalling">Signalling</a>
in the
<a href="./cellab.html#structure_of_column">section 1.2.4</a>)
of the territory referenced by the passed vector, and the second argument is
the kind of that territory.
Note that it is the parametrisation who defines size, content, and a compression method
of the memory reserved for any sigannling. We thus assume that <i>F</i><sub>TC</sub>
already has (or is build on) that information.
</td>
</tr>
</table>
<p>
Although the function <i>F</i><sub>TC</sub> is a part of a parametrisation of the
neural tissue (i.e. a user may implement it arbitrarily), there is a general
scheme of what steps the function should perform:
</p>
<ol>
<li>
Unpack and parse data referenced by <kbd>bits_of_cell</kbd>. This is often
implemented as construction of an instance of an user-defined type of a tissue
cell. The memory reference is passed to a constructor of that data type.
</li><li>
Invoke a procedure on the unpacked cell transforming
its current state to the next one. The computation typically depends on states of
synapses connected to the cell. The procedure may thus call the function
<kbd>get_connected_synapse</kbd> to get references to the memory of individual
synapses and also kinds of their source cells. The computation may also
depend on states of territories up to certain distance from the territory
in which the updated cell appears. The procedure may use the function
<kbd>get_signalling</kbd> to receive access to their memory. Note that the procedure
typically unpacks and parses memory of both synapses and signalling in a similar way
as we explained for the memories of the cell (i.e. by passing the memory to a
constructor of a particular user-defined type where the instance is constructed
by unpacking and parsing the content of the memory).
</li><li>
Pack and write the updated state of the tissue cell to the memory
referenced by <kbd>bits_of_cell</kbd> (i.e. overwrite the old content).
</li>
</ol>
<p>
We always assume <i>F</i><sub>TC</sub> is a single-threaded, thread-safe, and in-place
<a href="./cellab.html#r28">[28]</a>
procedure.
</p><p>
The algorithm is implemented in source files:
</p>
<ul><li>
<a href="../../../code/cellab/include/cellab/transition_algorithms.hpp">
    <kbd>transition_algorithms.hpp</kbd></a> and
</li><li>
<a href="../../../code/cellab/src/transition_of_cells_of_tissue.cpp">
    <kbd>transition_of_cells_of_tissue.cpp</kbd></a>
</li></ul>
<h3 id="parallel_enumeration">3.7&nbsp;&nbsp;&nbsp;Parallel enumeration of components</h3>
<p>
Let us consider an <i>m</i>-dimensional array of the size
<i>n<sub>0</sub></i>&times;&hellip;&times;<i>n<sub><i>m</i>&minus;1</sub></i>.
We want to enumerate all elements in the array in parallel using <i>k</i> independent
threads. Different threads are supposed to enumerate different elements of the array
and counts of elements enumerated by any two threads may differ at most by 1.
Our goal is thus to specify a recipe for each thread how to generate a sequence of
indices into the array. An index into the array is a tuple
(<i>x</i><sub>0</sub>,&hellip;,<i>x</i><sub><i>m</i>&minus;1</sub>), where
0&le;<i>x</i><sub><i>i</i></sub>&lt;<i>n</i><sub><i>i</i></sub> for each
<i>i</i>=0,&hellip;,<i>m</i>&minus;1.
</p><p>
Let us consider the following recurrent recipe: given an index
(<i>x</i><sub>0</sub>,&hellip;,<i>x</i><sub><i>m</i>&minus;1</sub>)
into the array and a number <i>e</i><sub>0</sub>&isin;{0,&hellip;,<i>k</i>},
called <em>extent</em>, we compute numbers
<i>e</i><sub><i>i</i>+1</sub>=&lfloor;(<i>x</i><sub><i>i</i></sub>+<i>e</i><sub><i>i</i></sub>)
    / <i>n</i><sub><i>i</i></sub>&rfloor;
for all <i>i</i>=0,&hellip;,<i>m</i>&minus;1, and if <i>e</i><sub><i>m</i></sub>=0,
then we compute a successor index into the array such that its <i>i</i>-th component
(where <i>i</i>=0,&hellip;,<i>m</i>&minus;1) is
(<i>x</i><sub><i>i</i></sub>+<i>e</i><sub><i>i</i></sub>) mod <i>n</i><sub><i>i</i></sub>.
If <i>e</i><sub><i>m</i></sub>&ne;0, then the index
(<i>x</i><sub>0</sub>,&hellip;,<i>x</i><sub><i>m</i>&minus;1</sub>)
is the last one, i.e. it has no successor.
</p><p>
Note that C++ standard says that operators <kbd>/</kbd> and <kbd>%</kbd> satisfy
<kbd>(x/y)*y+x%y==x</kbd>, for any non-negative integers <kbd>x</kbd> and positive integers
<kbd>y</kbd>. It means that <kbd>x%y==x-(x/y)*y</kbd>. Therefore, components
(<i>x</i><sub><i>i</i></sub>+<i>e</i><sub><i>i</i></sub>) mod <i>n</i><sub><i>i</i></sub>
of an index computed above can equally be expressed as
(<i>x</i><sub><i>i</i></sub>+<i>e</i><sub><i>i</i></sub>) &minus;
    &lfloor;(<i>x</i><sub><i>i</i></sub>+<i>e</i><sub><i>i</i></sub>)
    / <i>n</i><sub><i>i</i></sub>&rfloor;&middot;<i>n</i><sub><i>i</i></sub>
= <i>x</i><sub><i>i</i></sub>+<i>e</i><sub><i>i</i></sub> &minus;
    <i>e</i><sub><i>i</i>+1</sub><i>n</i><sub><i>i</i></sub>.
</p><p>
It is further known that any <i>m</i>-dimensional array of a fixed size
<i>n<sub>0</sub></i>&times;&hellip;&times;<i>n<sub><i>m</i>&minus;1</sub></i>
can always be stored in 1-dimensional array with the address function
<i>f</i>(<i>x</i><sub>0</sub>,&hellip;,<i>x</i><sub><i>m</i>&minus;1</sub>) =
    <i>x</i><sub>0</sub> +
    <i>x</i><sub>1</sub><i>n</i><sub>0</sub> +
    <i>x</i><sub>2</sub><i>n</i><sub>0</sub><i>n</i><sub>1</sub> +
    &hellip; +
    <i>x</i><sub><i>m</i>&minus;1</sub><i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;2</sub>,
see
[<a href="./cellab.html#r26">26</a>].
The function <i>f</i> is a bijection between indices into these two arrays.
</p><p>
Observe that
<i>f</i>(<i>x</i><sub>0</sub>+<i>e</i><sub>0</sub>&minus;<i>e</i><sub>1</sub><i>n</i><sub>0</sub>,
    &hellip;,
    <i>x</i><sub><i>m</i>&minus;1</sub>+<i>e</i><sub><i>m</i>&minus;1</sub>&minus;<i>e</i><sub><i>m</i></sub><i>n</i><sub><i>m</i>&minus;1</sub>)
=
<i>x</i><sub>0</sub>+<i>e</i><sub>0</sub>&minus;<i>e</i><sub>1</sub><i>n</i><sub>0</sub> +
(<i>x</i><sub>1</sub>+<i>e</i><sub>1</sub>&minus;<i>e</i><sub>2</sub><i>n</i><sub>1</sub>)<i>n</i><sub>0</sub> +
(<i>x</i><sub>2</sub>+<i>e</i><sub>2</sub>&minus;<i>e</i><sub>3</sub><i>n</i><sub>2</sub>) <i>n</i><sub>0</sub><i>n</i><sub>1</sub> +
&hellip; +
(<i>x</i><sub><i>m</i>&minus;1</sub>+<i>e</i><sub><i>m</i>&minus;1</sub>&minus;<i>e</i><sub><i>m</i></sub><i>n</i><sub><i>m</i>&minus;1</sub>)<i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;2</sub>
=
<i>f</i>(<i>x</i><sub>0</sub>,&hellip;,<i>x</i><sub><i>m</i>&minus;1</sub>) +
<i>e</i><sub>0</sub> &minus; <i>e</i><sub><i>m</i></sub><i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;1</sub>.
Further, according to equalities of expressions with the floor function &lfloor;&rfloor;, see
[<a href="./cellab.html#r27">27</a>],
we have
<i>e</i><sub><i>m</i></sub> =
&lfloor;
(<i>x</i><sub><i>m</i>&minus;1</sub> +
    (<i>x</i><sub><i>m</i>&minus;2</sub> +
        &hellip;
        (<i>x</i><sub>1</sub> +
            (<i>x</i><sub>0</sub> +
                <i>e</i><sub>0</sub>
                ) / <i>n</i><sub>0</sub>
            ) / <i>n</i><sub>1</sub>
        &hellip;)
        / <i>n</i><sub><i>m</i>&minus;2</sub>
    ) / <i>n</i><sub><i>m</i>&minus;1</sub>
&rfloor;
=
&lfloor;
(<i>e</i><sub>0</sub> + <i>x</i><sub>0</sub> + <i>x</i><sub>1</sub><i>n</i><sub>0</sub> +
    <i>x</i><sub>2</sub><i>n</i><sub>0</sub><i>n</i><sub>1</sub> +
    &hellip; +
    <i>x</i><sub><i>m</i>&minus;1</sub><i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;2</sub>)
    / (<i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;1</sub>)
&rfloor;
=
&lfloor;(<i>f</i>(<i>x</i><sub>0</sub>,&hellip;,<i>x</i><sub><i>m</i>&minus;1</sub>) +
<i>e</i><sub>0</sub>) / (<i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;1</sub>)&rfloor;.
It means that <i>e</i><sub><i>m</i></sub>=0, if and only if
(<i>x</i><sub>0</sub>+<i>e</i><sub>0</sub>&minus;<i>e</i><sub>1</sub><i>n</i><sub>0</sub>,
    &hellip;,
    <i>x</i><sub><i>m</i>&minus;1</sub>+<i>e</i><sub><i>m</i>&minus;1</sub>&minus;<i>e</i><sub><i>m</i></sub><i>n</i><sub><i>m</i>&minus;1</sub>)
is a valid index into our <i>m</i>-dimensional array (because valid indices are all those
satisfying
0 &le; <i>f</i>(<i>x</i><sub>0</sub>,&hellip;,<i>x</i><sub><i>m</i>&minus;1</sub>) +
<i>e</i><sub>0</sub> &lt; <i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;1</sub>).
Moreover, for <i>e</i><sub><i>m</i></sub>=0 our recurrent recipe computes from a given index
and an extent <i>e</i><sub>0</sub> such successor index which is shifted exactly by
<i>e</i><sub>0</sub> positions from the given index in the address mode
defined by the function <i>f</i>.
</p><p>
We are now ready to specify how individual threads use the presented recurrent recipe.
A thread <i>j</i>, where 0&le;<i>j</i>&lt;<i>k</i>, computes the first index from the
tuple (0,&hellip;,0) and the extent <i>j</i>, and any subsequent index
from the previous one and the extent <i>k</i>. The computation stops, when
<i>e</i><sub><i>m</i></sub> becomes non-zero.
</p><p>
Clearly, a thread <i>j</i> enumerates indices
{<i>f</i><sup>&minus;1</sup>(<i>j</i>+<i>i</i><i>k</i>) ;
    &exist;<i>i</i> . 0 &le; <i>j</i>+<i>i</i><i>k</i> &lt;
    <i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;1</sub>}.
There cannot be an index which is enumerated by two different threads <i>j</i> and <i>j</i>',
because existence of natural numbers <i>i</i> and <i>i</i>' such that
<i>j</i>+<i>i</i><i>k</i> = <i>j</i>'+<i>i</i>'<i>k</i>
implies that <i>j</i>-<i>j</i>' is an integer multiple of <i>k</i> (which cannot happen, since
<i>j</i>,<i>j</i>'&isin;{0,&hellip;,<i>k</i>&minus;1} and <i>j</i>&ne;<i>j</i>').
Further, all <i>k</i> threads together enumerate all indices into the array, because
{<i>f</i><sup>&minus;1</sup>(<i>j</i>+<i>i</i><i>k</i>) ;
    &exist;<i>j</i>,<i>i</i> . 0 &le; <i>j</i> &lt; <i>k</i> &and;
    0 &le; <i>j</i>+<i>i</i><i>k</i> &lt;
    <i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;1</sub>}
=
{<i>f</i><sup>&minus;1</sup>(<i>i</i>) ;
    &exist;<i>i</i> . 0 &le; <i>i</i> &lt;
    <i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;1</sub>}.
Finally, the size of the set
{<i>f</i><sup>&minus;1</sup>(<i>j</i>+<i>i</i><i>k</i>) ;
    &exist;<i>i</i> . 0 &le; <i>j</i>+<i>i</i><i>k</i> &lt;
    <i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;1</sub>}
of enumerated indices by a thread <i>j</i> is equal to the number of valid values for
<i>i</i> (satisfying the inequality), i.e. they are all integers in the interval
[0, (<i>n</i><sub>0</sub>&hellip;<i>n</i><sub><i>m</i>&minus;1</sub> &minus; <i>j</i>) / <i>k</i>).
Since <i>j</i> is always less than <i>k</i>, the number of integers in intervals for any two threads
may differ at most by 1.
</p><p>
The recipe is implemented in the source files
</p>
<ul><li>
<a href="../../../code/cellab/include/cellab/utilities_for_transition_algorithms.hpp">
    <kbd>utilities_for_transition_algorithms.hpp</kbd></a> and
</li><li>
<a href="../../../code/cellab/src/utilities_for_transition_algorithms.cpp">
    <kbd>utilities_for_transition_algorithms.cpp</kbd></a>
</li></ul>
<p>
as functions <kbd>go_to_next_index</kbd>, <kbd>go_to_next_column</kbd>, and
<kbd>go_to_next_coordinates</kbd>. Each function is dedicated for a concrete
dimensions of the array. Namely, the first functions is designed for <i>m</i>=1,
the second for <i>m</i>=2, and the last one for <i>m</i>=3. All these functions
internally use a function <kbd>go_to_next_value_modulo_range</kbd> which
provides a computation of values <i>e</i><sub><i>i</i></sub> and
(<i>x</i><sub><i>i</i></sub>+<i>e</i><sub><i>i</i></sub>) mod <i>n</i><sub><i>i</i></sub>.
</p><p>
The first transition algorithm discussed above
(<a href="./cellab.html#algorithm_synapses_to_muscles">section 3.1</a>)
uses the function <kbd>go_to_next_index</kbd> and all remaining transition
algorithms use the function <kbd>go_to_next_coordinates</kbd>. The function
<kbd>go_to_next_column</kbd> is used in the library
<a href="../cellconnect/cellconnect.html">cellconnect</a>
for enumeration of tissue columns (i.e. only of x and y coordinates).
</p><p>
We chose this kind of enumeration strategy due to simplicity of the implementation.
Indeed, the recipe is very simple and transition algorithms of the neural tissue do not
have to compute nor store any addition information (the initial extent is a loop counter
in a loop creating threads and the other extent is nothing but the passed number
of threads).
</p>


<h2 id="aggregation_with_parametrisation">4.&nbsp;&nbsp;&nbsp;Aggregation with parametrisation</h2>
<!--The construction of the neural tissue in the memory start by the construction of-->
<!--the static state. It is a parametrisation who provides data required for the-->
<!--construction. The passed data are parameters defining global immutable-->
<!--properties of the constructed neural tissue.-->
<!--Once the static state is created, the dynamic state is constructed-->
<!--according to data already stored in the static state. The constructed dynamic-->
<!--state has all its components initialised except parameters. Their initialisation-->
<!--is a task of the parametrisation. The dynamic state only provides access to the-->
<!--memory reserved for them. The library-->
<!--<a href="../cellconnect/cellconnect.html"><kbd>cellconnect</kbd></a>-->
<!--can be useful in that task.-->

<h2 id="references">References</h2>
<table>
    <tr><td align="right" valign="top" id="r01">[1]</td><td>
        Wikipedia: Cerebral cortex.
        <a href="https://en.wikipedia.org/wiki/Cerebral_cortex">
            https://en.wikipedia.org/wiki/Cerebral_cortex</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r02">[2]</td><td>
        Wikipedia: Cartesian space.
        <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">
            https://en.wikipedia.org/wiki/Cartesian_coordinate_system</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r03">[3]</td><td>
        Wikipedia: Neuron.
        <a href="https://en.wikipedia.org/wiki/Neuron">
            https://en.wikipedia.org/wiki/Neuron</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r04">[4]</td><td>
        Wikipedia: Synapse.
        <a href="https://en.wikipedia.org/wiki/Synapse">
            https://en.wikipedia.org/wiki/Synapse</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r05">[5]</td><td>
        Wikipedia: Axon.
        <a href="https://en.wikipedia.org/wiki/Axon">
            https://en.wikipedia.org/wiki/Axon</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r06">[6]</td><td>
        Wikipedia: Dendrite.
        <a href="https://en.wikipedia.org/wiki/Dendrite">
            https://en.wikipedia.org/wiki/Dendrite</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r07">[7]</td><td>
        Wikipedia: Glia cell.
        <a href="https://en.wikipedia.org/wiki/Neuroglia">
            https://en.wikipedia.org/wiki/Neuroglia</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r08">[8]</td><td>
        Thomas Trappenberg. Fundamentals of Computational Neuroscience.
        OXFORD University Press, 2010.
    </td></tr>
    <tr><td align="right" valign="top" id="r09">[9]</td><td>
        Wikipedia: Leaky integrate-and-fire neuron.
        <a href="https://en.wikipedia.org/wiki/Biological_neuron_model#Leaky_integrate-and-fire">
            https://en.wikipedia.org/wiki/Biological_neuron_model#Leaky_integrate-and-fire</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r10">[10]</td><td>
        <a href="http://www.izhikevich.org/publications/spikes.htm">
            http://www.izhikevich.org/publications/spikes.htm</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r11">[11]</td><td>
        Martin Anthony.
        <a href="https://books.google.fr/books?id=qOy4yLBqhFcC&pg=PA3&redir_esc=y#v=onepage&q&f=false">
            Discrete Mathematics of Neural Networks: Selected Topics</a>.
        SIAM, 2001.
    </td></tr>
    <tr><td align="right" valign="top" id="r12">[12]</td><td>
        Wikipedia: Hodgkin-Huxley neuron.
        <a href="https://en.wikipedia.org/wiki/Hodgkin%E2%80%93Huxley_model">
            https://en.wikipedia.org/wiki/Hodgkin%E2%80%93Huxley_model</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r13">[13]</td><td>
        Wikipedia: Serialisation.
        <a href="https://en.wikipedia.org/wiki/Serialization">
            https://en.wikipedia.org/wiki/Serialization</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r14">[14]</td><td>
        Wikipedia: Axon guidance.
        <a href="https://en.wikipedia.org/wiki/Axon_guidance">
            https://en.wikipedia.org/wiki/Axon_guidance</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r15">[15]</td><td>
        MBInfo: Axon guidance and growth cone.
        <a href="http://www.mechanobio.info/modules/go-0007411">
            http://www.mechanobio.info/modules/go-0007411</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r16">[16]</td><td>
        MBInfo: Axon guidance and growth cone.
        <a href="http://www.mechanobio.info/modules/go-0007411/1_go-0007411">
            http://www.mechanobio.info/modules/go-0007411/1_go-0007411</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r17">[17]</td><td>
        Wikipedia: Slit-Robo.
        <a href="https://en.wikipedia.org/wiki/Slit-Robo">
            https://en.wikipedia.org/wiki/Slit-Robo</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r18">[18]</td><td>
        Wikipedia: Ephrin.
        <a href="https://en.wikipedia.org/wiki/Ephrin">
            https://en.wikipedia.org/wiki/Ephrin</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r19">[19]</td><td>
        Wikipedia: Netrin.
        <a href="https://en.wikipedia.org/wiki/Netrin">
            https://en.wikipedia.org/wiki/Netrin</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r20">[20]</td><td>
        Wikipedia: Semaphorin.
        <a href="https://en.wikipedia.org/wiki/Semaphorin">
            https://en.wikipedia.org/wiki/Semaphorin</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r21">[21]</td><td>
        Wikipedia: Growth cone.
        <a href="https://en.wikipedia.org/wiki/Growth_cone">
            https://en.wikipedia.org/wiki/Growth_cone</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r22">[22]</td><td>
        Wikipedia: Myelin.
        <a href="https://en.wikipedia.org/wiki/Myelin">
            https://en.wikipedia.org/wiki/Myelin</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r23">[23]</td><td>
        Wikipedia: Action potential.
        <a href="https://en.wikipedia.org/wiki/Action_potential">
            https://en.wikipedia.org/wiki/Action_potential</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r24">[24]</td><td>
        Wikipedia: Modular arithmetic.
        <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">
            https://en.wikipedia.org/wiki/Modular_arithmetic</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r25">[25]</td><td>
        Wikipedia: Congruence relation.
        <a href="https://en.wikipedia.org/wiki/Congruence_relation">
            https://en.wikipedia.org/wiki/Congruence_relation</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r26">[26]</td><td>
        Wikipedia: Array address calculation.
        <a href="https://en.wikipedia.org/wiki/Row-major_order">
            https://en.wikipedia.org/wiki/Row-major_order</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r27">[27]</td><td>
        Wikipedia: Floor and ceiling functions.
        <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions">
            https://en.wikipedia.org/wiki/Floor_and_ceiling_functions</a>.
    </td></tr>
    <tr><td align="right" valign="top" id="r28">[28]</td><td>
        Wikipedia: In-place algorithm.
        <a href="https://en.wikipedia.org/wiki/In-place_algorithm">
            https://en.wikipedia.org/wiki/In-place_algorithm</a>.
    </td></tr>
</table>

</body>
</html>
